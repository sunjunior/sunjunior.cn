{"meta":{"title":"St.John的个人技术博客","subtitle":"递归和自举是实现人工智能的两大法宝","description":"程序员，喜编程，爱折腾，技术控","author":"St.John","url":"http://sunjunior.cn","root":"/"},"pages":[{"title":"","date":"2020-05-03T15:32:03.530Z","updated":"2017-03-05T14:36:40.510Z","comments":true,"path":"404.html","permalink":"http://sunjunior.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-24T13:04:37.318Z","updated":"2020-05-24T13:04:37.318Z","comments":true,"path":"about/index.html","permalink":"http://sunjunior.cn/about/index.html","excerpt":"","text":"坐标深圳 职业软件工程师 喜好读书、技术控、户外活动 自评伪极客，技术控，会不定期分享工作中总结的技术心得和项目经验，以码会友，欢迎拍砖。原有CSDN博客sunjunior的专栏不再更新内容。有疑问请发送邮件到sunjunior@163.com。同时也欢迎同行朋友一起探讨技术原理，共同进步！"}],"posts":[{"title":"完全用Linux系统工作","slug":"workonlinux","date":"2020-06-07T07:46:32.000Z","updated":"2020-06-07T06:19:32.284Z","comments":true,"path":"2020/06/07/workonlinux/","link":"","permalink":"http://sunjunior.cn/2020/06/07/workonlinux/","excerpt":"","text":"背景 本文是针对研发人员而言的，尤其是软件开发人员，重度依赖office套件和Adobe等第三方软件的开发人员除外。先表明个人观点：作为一名专业码农，完全可以用Linux系统完成日常的研发工作。本文中说的Linux实际上指的是GNU/Linux，包括了建立在Linux内核之上的各类基础设施（编译器，语言工具链）以及上层应用的集合。 我们之所以平时依赖Windows系统，可能在于Windows下系统历史更悠久，应用程序类型更丰富，软件很多，体验更好（对于非研发类员工来说)，不同类型的应用程序都有多种可以选择。比如Windows系统下的office办公套件，Adobe Photoshop作图套件，还有不少专业软件和游戏客户端只提供了Windows版本。另外，大都数同学从开始接触计算机开始，是用DOS系统或者Windows系统入门的，思维上先入为主，这也使得作为大多数开发人员，平时仍然喜欢将Windows系统作为主力开发的系统。但是随着这些年Linux系统生态逐渐发展和完善，特别是一些大厂比如谷歌，微软,包括国内的deepin，搜狗等公司也开始在Linux系统上开发一些基础应用软件，大大地方便了Linux系统的使用，同时也推动了Linux系统在非研发类人员之间的推广。 作为研发人员来说，用Linux系统进行应用程序开发比Windows系统更为方便，系统提供的各类命令行可以帮助我们高效完成工作。要知道，Linux系统是世界上那些顶级黑客经过近三十年联合开发，逐渐发展起来的一款开源操作系统。使用命令行操作，高效率完成工作是本系统的一大特色。实际上用命令行比用鼠标在图形界面上操作效率更高，更灵活，更方便。但这也使得对我们研发人员的要求更高了。其实入门如何使用Linux系统是很简单的，完全不用担心不会用。研发人员完全可以通过自学快速掌握常用的Linux系统命令行。Windows系统在图形界面（Windows 95）之前不是也有DOS系统么，完成一系列工作也需要记住大量的DOS命令。如今Linux系统也开发了各类GUI界面供我们选择，比较经典常用的GUI界面有GNOME、KDE、 LXDE、Deepin等等。当前Linux系统发布版本众多，如何选择一款适合在PC上使用的呢？这里根据用户使用流行度，这里推荐几款系统比较常用和好用的版本，比如流行的Ubuntu、Fedora、Archlinux、Deepin等。这几款Linux发布版本在个人PC上比较稳定，且版本有社区的支持，一般出现问题反馈给社区，社区就会作为bug解决了。研发人员在使用Linux系统上有哪些常用的软件和工具呢，下面我们就分门别类地讲讲，各类工具软件在Linux系统上有哪些常用的。 应用软件 本文以我使用的Linux桌面经验，讲讲不同类型的应用我们常用的工具有哪些。本文只涉及到开源、免费的工具软件。其他三方收费软件比如MATLAB，SAS，Beyond Compare等等不在讨论范围。首先，对于研发人员来说，主要就是程序设计与编码了。当前主流的IDE，我们研发人员主要在于配置简单，要支持所有主流语言的代码补全功能，代码重构等等。支持跨平台，Windows系统下有的，Linux下也有。我们列举下Linux系统下的各类主流IDE和工具。 主流IDE Codeblocks（http://www.codeblocks.org） Codeblocks是一款免费开源的C/C++开源工具，支持 GCC、MSVC++ 等多种编译器，甚至还可以导入 Dev-C++ 的项目。Code::Blocks 的优点是：跨平台。在Linux、Mac、Windows 上都可以运行，且自身体积小，安装配置非常方便。最新的版本为20.03版本，代码自动补全应该是开源IDE中做的体验非常好的一项功能了。 CodeLite（https://codelite.org） CodeLite是专门用于C，C ++，PHP和JavaScript（主要供使用Node.js的后端开发人员）编程语言的开源，免费，跨平台IDE，其在所有主要平台（OSX，Windows和Linux）上均能最佳运行。跟上面介绍的CodeBlocksIDE一样，不过语言支持范围更广。 Pycharm(https://www.jetbrains.com/pycharm/download/#section=linux) PyCharm是一个用于计算机编程的集成开发环境（IDE），主要用于Python语言开发，由捷克公司JetBrains开发，提供代码分析、图形化调试器，集成测试器、集成版本控制系统，并支持使用Django进行网页开发。JetBrains公司针对不同的语言都有一套对应的IDE,比如Java/Scala开发用IDEA，C/C++开发用CLion等等。 VSCode（https://code.visualstudio.com） Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统且开放源代码的代码编辑器[4]，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。通过各类插件安装，基本上可以支持所有主流语言的代码补全功能，也是程序员中使用最广泛的编辑器之一。 Qt Creator（https://www.qt.io/offline-installers） Qt Creator 是一款跨平台的集成开发环境，特别针对Qt开发者，是Qt SDK组成的一部分，可运行于Windows, Linux/X11及Mac OS X等桌面操作系统，允许开发者为多桌面环境及移动设备平台创建应用程序。它包括一个可视化调试工具和集成的 GUI 版面和外形设计师。这个编辑器的功能包括语法高亮度显示和自动完成。Qt Creator 在 Linux 上，使用 GCC/Clang的 C++ 编译器。Qt Creator也是为数不多的代码补全功能好用的IDE之一。QT Creator也是在Linux上进行C/C++ GUI图形软件的主力开发工具，很多软件在Linux下的版本就是用Qt开发的，比如beyond compare比较工具，金山公司的WPS办公套件。 GVim（https://github.com/vim/vim-win32-installer/releases） Vim是从vi发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器，素有编辑器之神的美誉。GVim是VIM的图形客户端，我们可以通过定制配置之后，改造成一个美观好用IDE，改造之后的IDE几乎支持所有主流语言的代码补全功能，这也是我平时开发主力的IDE。 其他IDE Linux下还有很多IDE，比如eclipse，也是用的比较多的。这里本文主要想强调的是当前用Linux做应用开发，几乎不存在因为IDE生态不完善而影响开发效率的问题。 图形编辑软件 研发人员在平时工作中软件编写过程中，最常用的就是要画流程图或者用UML语言来设计功能了，我们在Windows系统下，有visio等工具使用，或者利用第三方收费工具，比如EA（Enterprise Architect）、国产亿图edraw。在Linux下，也有不少好用的开源工具辅助我们画UML图。比如Diag画图软件，yEd等等，画脑图也有xmind可用。大家在平时工作中用到的功能，基本上都能找到对应的。这里还有一些通用的画图软件，比如MyPaint, Pinta, GIMP, Graphviz等等，这里就不一一枚举了。下面图片中的是我本人电脑中常使用的画图工具软件（当然我们可以支持下国产，直接购买亿图的Linux版本）： 办公套件 对标windows下的office套件，Linux下有什么可以替代的呢？我们有libreoffice套件，该套件是Linux系统的标配，但由于跟office在布局排版上不一样，可能用的不太顺手。另外，我们还有永中office套件，该工具仿照了office 2003和office 2007版本，布局排版基本一样，当前永中已经不更新了，需要网上下载以前版本的deb或者rpm包之后，手工安装。目前金山公司的WPS有对应的Linux版本，Linux系统下配置软件源之后可以用命令一键安装，部署好了基本可以达到开箱即用。WPS在界面布局上跟Windows下的office也是一致的，这也是在Linux环境下用office套件办公的不二选择。 对于研发人员来说，用office套件的频度不大，反而我们有时候需要阅读PDF文档用什么工具效率更高；另外撰写个人博客时用什么markdown工具更为方便；打字用什么输入法更快速等等。这些诉求对于Linux系统来说，自然都是不在话下。当前不但有而且很多，这里我们只列举本人使用得比较多的PDF工具和markdown工具。PDF工具多年之前有一些开源的，但是功能少，大都只是阅读功能。这里PDF推荐用master pdf editor，当前最新版本为5.0版本，markdown工具用typora，我们不需要对markdown语法记忆，该该markdown工具所见即所得，非常好用，本文也是用该工具完成的。输入法自然用搜狗输入法了。 另外浏览器也是我们用的频率最多的工具了，Linux系统下浏览器的2大阵营，Chrome浏览器和FireFox火狐浏览器，2款浏览器各有特点，依赖喜好而定。都支持丰富的插件，是前端开发调测用的最多的2款浏览器了。 影音播放 影音这部分在多年前（大概2012年左右）支持不完善，需要手工配置（需要命令行安装多种音视频解码器）后才可以支持播放，由于配置要求较高，使得不少人对Linux下无法播放影音文件产生了质疑。经过这么些年的更新发展，当前我们可以直接在软件商店中点击安装，或者通过命令行安装VLC播放器或者SMPlayer播放器，就可以对当前主流格式的视频，音频一网打尽。 其他工具 Linux上工具数以万计，对于平时我们开发而言，利用Linux系统自带shell命令和常用的工具，平时基本上可以高效率完成日常工作。其他专用工具需要单独搜寻，比如排版工具LaTeX，一般都会有对应的Linux版本，如果没有也会有替代方案。目前很多大型公司都开始重视Linux系统上的应用市场份额了。比如腾讯最近也开始将QQ版本逐步更新。像之前的通信社交软件skype， 团队协作软件teamviewer都有Linux版本的。当前应用软件开发都是优先考虑跨平台。Linux系统缺少游戏和游乐功能么？答案是不缺，下载安装一个steam平台，可以在Linux上玩多数免费游戏，足够日常娱乐了。另外听歌可以下载网易云音乐客户端，跟Windows下的体验并无差别。本人用的是终端版本的网易云音乐，更加地轻便，丝滑流畅。 总结 在Linux桌面上进行研发，对于大都数程序员来说是没有任何问题的。对于一般的影音娱乐，当前系统上也有许多软件可供选择。对于公司而言，用开源的系统最大的优势是节省成本资源，并且社区对该版本提供技术支持。而对于程序员来说，用Linux系统做开发，省去了安装各种开发工具，比如ssh/scp工具，系统是自带的。至于被吐槽的系统娱乐功能太少的问题，反而成为了公司使用该系统的优势，公司的计算机是用来办公的，不是用来玩游戏的，我们玩游戏适可而止就好。总的来说，用Linux系统上研发相比Windows而言，工具链相当完善，许多工具命令系统默认就有，效率甚至会比Windows下开发更高。这里需要说明的是，安装Linux系统对硬件的要求比较高，主要是系统驱动还不完善，很多厂商只开发了Windows下的驱动，Linux下驱动要么缺少，要么功能有残缺。尤其是显卡驱动。N卡的驱动更加稳定些。","categories":[],"tags":[{"name":"研发","slug":"研发","permalink":"http://sunjunior.cn/tags/%E7%A0%94%E5%8F%91/"}]},{"title":"实现最短路径问题的2种常用算法","slug":"dijkstra","date":"2020-05-23T23:56:07.000Z","updated":"2020-05-27T15:30:42.142Z","comments":true,"path":"2020/05/24/dijkstra/","link":"","permalink":"http://sunjunior.cn/2020/05/24/dijkstra/","excerpt":"","text":"背景最短路径问题是计算机图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。维基百科中将最短路径问题划分了几种类型，算法具体的形式包括： 确定起点的单源最短路径问题 - 即已知起始结点，求最短路径的问题。适合使用Dijkstra算法 确定终点的最短路径问题 - 与确定起点的单源路径问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的单源最短路径问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。 确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。 全局最短路径问题 - 求图中所有的节点之间的最短路径。适合使用Floyd-Warshall算法 算法设计思想本文重点讨论Dijkstra算法和Floyd-Warshall算法的实现思路。本文不会详细探究这两个算法理论支撑基础，重点在于说明这两种算法的使用场景及代码实现。我们知道图的广度优先算法BFS可以算出任意2个节点之间的最短路径，这里有个隐含条件，每2个节点之间之间的边的权重都是相等的，这样我们用队列实现的时候对于同一层次的节点入队列时是不分优先级顺序的。但是如果节点之间连接的边的权重是不一样的，则需要对经典的BFS算法进行改造，将普通的队列修改为优先队列。 首先，我们先实现比较简单的Floyd-Warshall算法，该算法核心代码就5行，但算法思想包含了动态规划，我们以节点i和节点j的最短路径为例， 我们用dp(i, j)表示节点i和节点j的最短路径，那么可以有如下公式： dp(i, j) = min \\{dp(i, prev(j)) + val(prev(j), j)， dp(i,j)\\}令 k = prev(j)，则有k表示为所有与j相邻的节点，这里我们取最小值，那如何更新最小值呢，我们可以用用一个二维数组来表示2个节点之间的边，边的权重为其路径，没有直接相邻的2个节点之间的路径长度设置为无穷大，对于节点i和节点j来说，如果经过了节点k，那我们只需要计算dp(i, j)的值和dp(i,k) + dp(k,j)的值哪个更小一些，即对所有经过节点k的节点i和节点j的路径，我们通过以下公式更新： dp(i,j)=dp(i,k)+dp(k,j) \\space\\space\\space\\space if \\space\\space\\space dp(i, j) > dp(i, k) + dp(k, j)将所有经过节点k(k=1~n)遍历完之后，我们就会得到最终的二维数据值，该值描述了2个节点之间的最短路径。 最后，我们再实现Dijkstra算法，Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法可以基于BFS算法，内部维护一个优先队列实现。问题可以描述为：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）,这里需要注意的是，节点之间的边不能有负权边。 Floyd-Warshall算法实现首先，我们先抛出Floyd-Warshall算法的核心代码，就5行代码： 12345for k in range(n): for i in range(n): for j in range(n): if dp[i][j] &gt; dp[i][k] + dp[k][j]: dp[i][j] = dp[i][k] + dp[k][j] 我们用一个实际的例子来理解该算法，下图为无向图，意思为节点i到节点j的距离和节点j到节点i的距离是相等的，当然我们这个算法可以用于有向图，节点i到节点j的距离和节点j到节点i的距离不一定相等，该算法照样可以算出两两节点之间的最短距离。 这里我们首先用一个二维数组dp表示所有节点之间两两节点之间的关系，二维数组的值表示当前的最短路径。设定第i个节点到第i个节点本身的距离为0，即 dp(i, i) = 0, 无直接相连节点之间的距离为无穷大。上图一共是5个节点，我们用5 * 5的二维数组dp表示节点间关系即距离。 A B C D E A 0 2 4 inf 10 B 2 0 3 inf 7 C 4 3 0 4 3 D inf inf 4 0 5 E 10 7 3 5 0 我们这里采用python语言实现其算法，最主要的就是根据上面图的关系来构造上面的dp二维数组（代码中的distance变量）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import mathdef print_path(path, i, j): def helper(path, i, j): if path[i][j] != math.inf: helper(path, i, path[i][j]) helper(path, path[i][j], j) else: print(\"--&gt;\", chr(ord('A') + j), end='') print(chr(ord('A') + i), end='') helper(path, i, j)# graph表示图节点之间的关系，可以用不同形式的数据结构# 表示，node_num用于表示节点个数def floyd(graph, node_num: int): distance = [[math.inf] * node_num for _ in range(node_num)] path = [[math.inf] * node_num for _ in range(node_num)] for node in graph: row = ord(node) - ord('A') distance[row][row] = 0 adjcents = graph[node] for adjcent, val in adjcents.items(): col = ord(adjcent) - ord('A') distance[row][col] = val # 套用Floyd-Warshall算法核心代码 for k in range(node_num): for i in range(node_num): for j in range(node_num): if distance[i][j] &gt; distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] path[i][j] = k # 将节点i和节点j之间通过节点k的记录起来 return path, distancegraph = &#123; 'A': &#123;'B': 2, 'C': 4, 'E': 10&#125;, 'B': &#123;'A': 2, 'C': 3, 'E': 7&#125;, 'C': &#123;'A': 4, 'B': 3, 'D': 4, 'E': 3&#125;, 'D': &#123;'C': 4, 'E': 5&#125;, 'E': &#123;'A': 10, 'B': 7, 'C': 3, 'D': 5&#125;&#125;# 打印A到E的最短距离7path, distance = floyd(graph, len(graph))i = ord('A') - ord('A') # 将字符转换为对应的索引j = ord('E') - ord('A')print(distance[i][j]) # 打印A到E的最短路径为7print_path(path, i, j) # A--&gt; C--&gt; E 该算法由于是计算的所有节点中每2个节点之间的最短路径，这里明显看出算法的时间复杂度为O(n^3)。因此也可以同样适用于单源最短路径的计算问题，只不过有点高射炮打蚊子的嫌疑了，我们用Dijkstra算法则可以做到O(E + VlogV) Dijkstra算法实现Dijkstra算法是解决单源最短路径的最佳算法，同时节点之间不能有负权边。下面直接用BFS算法+优先队列实现其功能。 123456789101112131415161718192021222324252627282930313233343536373839404142import mathimport heapqgraph = &#123; 'A': &#123;'B': 2, 'C': 4, 'E': 10&#125;, 'B': &#123;'A': 2, 'C': 3, 'E': 7&#125;, 'C': &#123;'A': 4, 'B': 3, 'D': 4, 'E': 3&#125;, 'D': &#123;'C': 4, 'E': 5&#125;, 'E': &#123;'A': 10, 'B': 7, 'C': 3, 'D': 5&#125;&#125;def init_distance(graph: dict, s): distance = &#123;s: 0&#125; for node in graph: if node != s: distance[node] = math.inf return distancedef dijkstra(graph: dict, s: str): distance = init_distance(graph, s) parent = &#123;s: None&#125; pqueue = [] heapq.heappush(pqueue, (0, s)) # 加入源节点 seen = set() while pqueue: dis, node = heapq.heappop(pqueue) seen.add(node) for w in graph[node]: if w not in seen: if distance[w] &gt; dis + graph[node][w]: heapq.heappush(pqueue, (dis + graph[node][w], w)) parent[w] = node distance[w] = dis + graph[node][w] return parent, distanceif __name__ == '__main__': parent, distance = dijkstra(graph, 'A') print(parent) # &#123;'A': None, 'B': 'A', 'C': 'A', 'E': 'C', 'D': 'C'&#125; print(distance) # &#123;'A': 0, 'B': 2, 'C': 4, 'D': 8, 'E': 7&#125; 总结Floyd-Warshall算法比Dijkstra算法实现要简单很多，如果求最短路径，让大家偷懒的方法就直接用Floyd算法，这个算法通用性更广，既可以算全局两两节点的最短路径，当然也可以算单源最短路径，但算法复杂度为 O(n^3)；而Dijkstra算法实现则要复杂一些,对于某些场景，用这个算法实现指定节点到其他所有节点的最短路径时间复杂度更低点。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://sunjunior.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"新秀语言Python与老牌语言Perl的比较","slug":"language","date":"2020-05-17T02:43:38.000Z","updated":"2020-05-24T04:55:36.726Z","comments":true,"path":"2020/05/17/language/","link":"","permalink":"http://sunjunior.cn/2020/05/17/language/","excerpt":"","text":"背景本人从事嵌入式软件开发已经有8个年头了，最开始是用C/C++做嵌入式底层软件开发。期间利用Qt Gui(C++ GUI开发框架)开发过补丁制作小工具，要说用Qt SDK开发程序，比之前开发效率高了不少。也用过Perl脚本编写自动化脚本进行软件测试。但是随着项目变更，期间还用过一段时间java，最近一年多时间搞运维相关的工作，自然用的语言开始以脚本为主了，平时主要利用脚本三剑客Python/Shell/Perl等进行自动化工具的编写工作。Python语言简单的语法结构，赢得了很多领域从业人事的青睐，也包括非计算机编程专业的同学，都将Python作为编程的首选语言。其实Python这门语言和它的兄弟语言Perl之间有很多相似点，这2门语言发展历史都差不多，为什么Python语言越来越热门，而Perl语言逐步走向衰落了呢？在我看来，Python语言在设计上做到了实用性，易用性和严谨性的一种平衡，对面向对象支持也比较彻底，另外虽然作为一门脚本语言，数据类型的定义上更为严格，比如不同类型之间不能隐式转换，这也使得可维护性，可读性更强。下面就谈谈这2种语言的差异点。 语言差异比较二者都是属于脚本范畴，发展历史都比较接近，语法相比C/C++/Java等编译型的语言来说，语法结构更加简单。Python与Perl都内置了常用的数据结构，比如列表和字典，同时这2门语言语法结构简单，都是用简单的符号来表示不同的含义。Python语法更加简洁点，一般语句不加分号结尾，变量命名跟C语言一样，采用缩进的方式来组织代码块。而Perl语法继承了C语言语法特点，一般用分号表示表达式语句的结尾，变量命名一般最前面要加一个美元符号$, 代码块用一组花括号来组织。Python的设计哲学为用一种方法，最好只有一种方法来做一件事情；而Perl设计恰好相反，Larry Wall认为，不要在语言设计上阻碍程序员想做的任何事情，其设计Perl语言理论是不仅仅一种方法做一件事，条条大路通罗马。这也使得Perl的语法比Python在表达上更为丰富。对于条件语句来说，既有肯定的if语句，也有否定含义的unless语句；对于循环语句来说，既有肯定语义的while,for语句，也有否定语义的until语法结构。而对于Python而言，对于每种语法结构而言，都是比较固定的写法。Perl语言条件真假是根据上下文来隐式转换之后表示真假的，字符串和数字类型是根据上下文环境来判断的，而Python有着严格的类型系统，一般来说，字符串类型(str)和数字类型(int)的变量是不能放到一起参与计算的。这也使得Python编写的程序相比Perl语言来说，可维护性更好一些。Perl汲取了C语言、awk、Shell脚本等语言的语法，因此语法上和C语言很类似。后来的PHP和ruby等语言又在Perl语言的基础上进一步发展起来的。言归正传，Python与Perl之间语法很多地方都相似，但是Perl语言的各种数据结构既可以通过值表示，也可以通过引用表示。比如我们用一个数组表示1~5，我们可用一个数组直接表示值，也可以用引用方式表示，这点跟C语言也比较类似。对比而言，Python语言一般用引用方式来表示；hash（字典）数据结构也是类似的做法。这也是两者在语法表示上最大的一个差异吧。 123456789101112131415# Perl通过传值方式传值数组my @a = (0, 1, 2, 3, 4);for my $item (@a) &#123; print($item, \"\\n\");&#125;print(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\n\");# Perl通过引用方式创建数组my $ref = [0, 1, 2, 3, 4];my $length = @&#123;$ref&#125;;for (my $index = -1; $index &lt; $length; $index++)&#123; print($ref-&gt;[$index], \"\\n\")&#125;# Perl引用一个数组，类似C语言指针指向数组的首地址my $ref = \\@a; 1234# Python一般通过引用创建数组a = [0, 1, 2, 3, 4]for index, val in enumerate(a): print(index, val) 另外需要提到的是，Python比Perl在面向对象表达上更为彻底，Perl的面向对象对于创建的对象模型暴露给了用户，更像是人工模拟的面向对象，而Python则是将对象模型实现细节隐藏到了语法内部，但本质上这两名语言在对象存储上一般都用字典来保存的。我们这里举一个例子就明白了。 12345678910111213141516171819202122232425262728package Location;use strict;use warnings FATAL =&gt; 'all';sub new &#123; my $class = shift; # 这里对象存储是放到字典里面的，需要显示的存储 my $self = &#123; _longitude =&gt; shift, _latitude =&gt; shift &#125;; bless($self, $class); return $self;&#125;sub get_longitude &#123; my $self = shift; return $self-&gt;&#123;_longitude&#125;;&#125;sub get_latitude &#123; my $self = shift; return $self-&gt;&#123;_latitude&#125;;&#125;1;package main;my $location = Location-&gt;new(12.22, 22.44);print($location-&gt;get_latitude(), \"\\n\");print($location-&gt;get_longitude(), \"\\n\"); 如果是Python来写面向对象的代码，则要简单得多，因为对象属性的存储语言默认就是放到dict里面的，不需要显示指定。 1234567891011121314151617class Location: def __init__(self, longitude, latitude): self.longitude = longitude self.latitude = latitude @property def get_longitude(self): return self.longitude @property def get_latitude(self): return self.latitudeif __name__ == '__main__': location = Location(12.22, 22.44) print(location.get_longitude) print(location.get_latitude) 总结总的来说，Python与Perl这两种语言，语法虽然差异大，但语言之间有不少共性地方。相比而言，Perl在语法表达方式上更为丰富，对于一般人来说反而思考负担太重，而且类型转换太随意。不过也需要考虑到Perl的发展历史，当时产生Perl脚本语言的时候，OOP编程范式还没有成为主流，那个时候的Perl更多地是替换C语言这类强类型语言，补充C语言在编写效率上的劣势，成为运维领域的专属语言。如今由于Perl语言语法规则太多，对于一般人来说可能hold不住，反而Python语言在语法上由于写法的一致性，获得了不少非计算机专业人员的青睐。现在Python语言的热度紧随C语言和Java语言之后，如今随着大数据，AI、数据科学的兴起，Python也在这些领域内发光发热。的确，Python语言语法简洁，精美，用很简短的符号表示不同的数据结构，用缩进来表示层次递进关系，比如我们分别用方括号[]和花括号{}来声明数组和字典，还有各种语法糖相关的东西，语法抽象的层次更高，语法使用上基本接近我们人类思维方式。这两年来，我也逐步体会到了Python的语言语法的优美之处，平时上网刷刷算法什么的，首选Python语言实现。尤其是在平时工作，验证方案的正确性，我们可能只需要用到短短几行代码就可以搞定，确实效率高；对工作中的问题，我们用Python语言来更多地专注在解决方案（业务实现）上，而不是把精力都投入到了C/C++等语言在底层实现细节上，包括手工释放内存。","categories":[],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"回溯算法的基本原理及代码框架","slug":"backtrack","date":"2020-05-16T12:24:12.000Z","updated":"2020-05-23T15:58:20.756Z","comments":true,"path":"2020/05/16/backtrack/","link":"","permalink":"http://sunjunior.cn/2020/05/16/backtrack/","excerpt":"","text":"回溯法的定义回溯法(Backtracking)属于暴力搜索法中的一种，维基百科对该方法的解释是回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。 回溯法原理回溯算法一般要求就是在给定的有限空间内搜索满足条件的路径。 当我们通过画图得知数据结构（解空间）类似一颗N叉树，要求每个路径分支作为一个解时，那么就可以考虑用回溯法来实现。回溯法跟树的遍历搜索非常相似，因此很多时候我们把树的深度优先算法(DFS, Depth First Search)稍微改造一下，就可以得到回溯法的实现框架了。 回溯法通常用递归方法来实现。递归也是所有算法的一个底座（基础的基础），后面单独开篇讨论递归算法。这里要特别注意的是，尤其是考虑用回溯法遍历树的节点时，我们可能先处理根节点，然后再考虑左右子树的情况。我们可用一个堆栈的数据结构来保存访问的节点，这里记作path，当遍历完子节点之后，要记得把最近一次访问节点从path堆栈中弹出，因为这个时候子树已经访问完成，遍历的指针回到了其父节点，此时path中不应该包含子节点了。另外如果遍历的树的空间复杂度较高，我们在遍历节点时就要考虑对部分路径进行剪枝，提高搜索效率。 回溯法的代码框架下面我们从回溯法代码框架进一步了解其实现流程，同时也加强对树的遍历算法和递归算法思想的把握。我们先列出回溯法的代码框架，然后我们以打印一个序列的全排列，用回溯算法实现其核心代码部分。我们用backtrack函数表示回溯算法，这里一共有3个关键的入参，我们用符号sequence, path, result来表示。其中我们用sequence来表示可以选择的序列或者子树，path用于保存从根节点到当前遍历节点所访问过的所有节点。result用于保存满足给定条件的所有path的集合。 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 1234567891011121314151617181920from typing import Listdef backtrack(sequence: List[str], path: List[str], result: List[List[str]])-&gt; None: if not sequence: #递归结束条件，一般是到了序列为空或者最后一个时，对于树型结构来说，一般是到达了叶子节点 result.append(path[:]) #对满足条件的path进行处理 return for index, node in enumerate(sequence): # 对当前树层次的可选择节点遍历 path.append(node) # 这里先对根节点进行处理 remains = sequence[:index] + sequence[index+1:] #得到子树的可选择节点 backtrack(remains, path, result) #递归调用，进入子树中，对子树采用相同的处理方式 path.pop() # 回到父节点后，将之前压栈的节点弹出def permute(sequence: List[str])-&gt;List[List[str]]: result = [] backtrack(sequence, [], result) return resultsequence = [\"A\", \"B\", \"C\"]print(permute(sequence)) 回溯法实战下面我们以leetcode的113题为例，讲解下用回溯算法怎么处理，题中是给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。给定如下二叉树，以及目标路径和为22。返回5-&gt;4-&gt;11-&gt;2, 5-&gt;8-&gt;4-&gt;5这2条路径。 这里要打印的是满足要求的路径，涉及到路径相关的，我们第一优先考虑树的深度优先算法或者回溯法来求解。根据上面讲解的代码框架套路，我们直接可以套用，完整的代码如下： 12345678910111213141516171819202122232425262728293031from typing import Listclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def backtrack(self, root:TreeNode, path: List[int], result: List[List[int]], sum: int)-&gt;None: if not root: return sum -= root.val path.append(root.val) if root.left is None and root.right is None: # 叶子节点 if sum == 0: #减到叶子节点值如果恰好为0，则满足要求 result.append(path[:]) return if root.left is not None: self.backtrack(root.left, path, result, sum) path.pop() if root.right is not None: self.backtrack(root.right, path, result, sum) path.pop() def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: result = [] self.backtrack(root, [], result, sum) return result 在上面题中我们只需要把框架中的代码修改如下： 修改sequence参数为二叉树的root(这里root表示一棵树，本身就代表最多有2种选择，左子树和右子树)， path用于保存根节点和当前节点遍历的所有节点，result保存满足条件的所有path路径。这样看起来，是不是和上面的排列思路非常类似。再比如leetcode的第17题，题目描述如下图所示： 这里我们如果直接用暴力搜索的话，代码可能会这么写，比如按照输入给出的“23”,打印所有的组合： 1234567891011121314151617letters_map = &#123; \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"&#125;digits = \"23\"result = []for i in letters_map[\"2\"]: for j in letters_map[\"3\"]: #这里需要2层循环 result.append(i + j)print(result) 这里有个问题，如果给出的输入为“235”的话，那么我们还得新增一个循环，有几个输入就需要几个循环，由于循环个数是不定的，因此常用常规的循环无法满足代码实现，我们这里发现，循环条件的格式都是类似的，只是遍历的数字key不一样，考虑用递归方法来求解就能解决个数不一定的问题。本质上，该题的实现方法用的是回溯法做的（回溯法就是我们文章开头说的暴力搜索的一种)，只是该题比较简单，直接按照一定顺序遍历所有节点即可。我们继续套用上面的代码框架，把条件稍微调整下，这个程序代码如下： 123456789101112131415161718192021222324252627from typing import Listletters_map = &#123; \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"&#125;class Solution: def backtrack(self, digits, path: List[str], result: List[List[str]], index)-&gt;None: if index == len(digits): result.append(''.join(path[:])) return for c in letters_map[digits[index]]: path.append(c) self.backtrack(digits, path, result, index + 1) path.pop() def letterCombinations(self, digits: str) -&gt; List[str]: result = [] self.backtrack(digits, [], result, 0) return result 回溯法套路就讲解这么多，是不是很简单，实际上就是树的遍历而已，只是在遍历过程中，我们需要记录一些关键信息，比如这里需要记录遍历节点（按照遍历节点的先后顺序记录到一个堆栈中)而已，其他的跟树的遍历搜索规则类似。把上面的原理和代码套路搞懂了之后，关于回溯法的题目基本就可以做到秒杀了。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://sunjunior.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"图的遍历搜索算法之BFS和DFS","slug":"bfs-and-dfs","date":"2020-05-04T23:16:03.000Z","updated":"2020-05-23T23:58:15.448Z","comments":true,"path":"2020/05/05/bfs-and-dfs/","link":"","permalink":"http://sunjunior.cn/2020/05/05/bfs-and-dfs/","excerpt":"","text":"图结构中常用的２种遍历算法为BFS(Breadth-First-Search)和DFS(Depth-First-Search) 。顾名思义，BFS算法称为宽度(广度)优先算法，有的地方也称为层次遍历算法。BFS算法是从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则终止算法。DFS算法是一种用于遍历搜索树或图的另一种算法。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止一般来说,BFS算法比DFS算法用法更广。BFS算法实现需要维护一个队列，而DFS算法实现需要维护一个栈，算法实现流程大致一样。下面以一个图的遍历为例，分别用BFS算法和DFS算法来实现。代码采用python语言，其他语言可以其思想修改为对应的写法即可。下面我们以一颗完全二叉树为例，分别用BFS算法和DFS算法来遍历，打印访问的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546graph = &#123; \"A\": [\"B\", \"C\"], \"B\": [\"D\", \"E\"], \"C\": [\"F\", \"G\"], \"D\": [\"H\", \"I\"], \"E\": [\"J\"], \"F\": [\"K\", \"L\"], \"G\": [\"M\"], \"M\": [\"N\", \"O\"]&#125;def bfs(graph, seed): queue = [] visited = set() queue.append(seed) visited.add(seed) while queue: vertex = queue.pop(0) if vertex in graph: nodes = graph[vertex] for w in nodes: if w not in visited: queue.append(w) visited.add(w) print(vertex)bfs(graph, \"A\")def dfs(graph, seed): stack = [] stack.append(seed) visited = set() visited.add(seed) while stack: vertex = stack.pop() if vertex in graph: nodes = graph[vertex] for w in nodes: if w not in visited: stack.append(w) visited.add(w) print(vertex)dfs(graph, \"A\") 对于树的遍历来说，我们还可以用递归的方式来求解。我们可以打印所有根节点到叶子节点的路径： 1234567891011121314151617181920212223242526272829from typing import Listdef dfs(graph, result:List[List[str]], path: List, seed): path.append(seed) if seed not in graph: # 叶子节点 result.append(path[:]) path.pop() else: for node in graph[seed]: dfs(graph, result, path, node) path.pop()def find_root_leaf_path(seed): graph = &#123; \"A\": [\"B\", \"C\"], \"B\": [\"D\", \"E\"], \"C\": [\"F\", \"G\"], \"D\": [\"H\", \"I\"], \"E\": [\"J\"], \"F\": [\"K\", \"L\"], \"G\": [\"M\"], \"M\": [\"N\", \"O\"] &#125; result = [] dfs(graph, result, [], \"A\") for path in result: print(path)find_root_leaf_path(\"A\") 我们还可以打印从树根节点到叶子节点等于指定和的所有路径，比如25。这里我们观察图，得知有2条路径： 我们把上面的代码稍作修改，即可以完成上面的功能： 12345678910111213141516171819202122232425262728293031323334from typing import Listdef dfs(graph, capacities, result:List[List[str]], path: List, seed, target): path.append(seed) target -&#x3D; capacities[seed] if seed not in graph: # 叶子节点 if target &#x3D;&#x3D; 0: result.append(path[:]) path.pop() else: for node in graph[seed]: dfs(graph, capacities, result, path, node, target) path.pop()def find_root_leaf_path(seed): graph &#x3D; &#123; &quot;A&quot;: [&quot;B&quot;, &quot;C&quot;], &quot;B&quot;: [&quot;D&quot;, &quot;E&quot;], &quot;C&quot;: [&quot;F&quot;, &quot;G&quot;], &quot;D&quot;: [&quot;H&quot;, &quot;I&quot;], &quot;E&quot;: [&quot;J&quot;], &quot;F&quot;: [&quot;K&quot;, &quot;L&quot;], &quot;G&quot;: [&quot;M&quot;], &quot;M&quot;: [&quot;N&quot;, &quot;O&quot;] &#125; capacities &#x3D; &#123; &quot;A&quot;: 10, &quot;B&quot;: 4, &quot;C&quot;: 2, &quot;D&quot;: 8, &quot;E&quot;: 10, &quot;F&quot;: 7, &quot;G&quot;: 5, &quot;H&quot;: 2, &quot;I&quot;: 2, &quot;J&quot;: 3, &quot;K&quot;: 6, &quot;L&quot;: 9, &quot;M&quot;: 5, &quot;N&quot;: 6, &quot;O&quot;: 3&#125; result &#x3D; [] target &#x3D; 25 dfs(graph,capacities, result, [], &quot;A&quot;, target) for path in result: print(path)find_root_leaf_path(&quot;A&quot;) 总的来说，BFS算法比DFS算法使用范围更广，涉及到二维平面搜索，图搜索，走迷宫等等优先考虑BFS，因为BFS总是可以找到任意2个节点之间的最短路径。而对于遍历树的路径，字符串排列组合等等可以采用DFS算法。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://sunjunior.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"简单用GTest单元测试框架编写测试用例","slug":"gtest","date":"2020-05-03T15:32:03.530Z","updated":"2020-05-04T00:41:54.739Z","comments":true,"path":"2020/05/03/gtest/","link":"","permalink":"http://sunjunior.cn/2020/05/03/gtest/","excerpt":"","text":"GTest单元测试框架浅析Google发布的gtest是一款跨平台单元测试框架，本文是在archlinux上直接安装gtest之后，用codeblocks编写了一个简单的16进制字符串转数字的函数，最后利用gtest测试框架来输出测试用例，保证函数的正确性。在使用gtest时，需要在IDE编译选项中添加-lgtest选项，不然可能会链接报错。下面是简单的用法和执行结果： #include &lt;gtest/gtest.h&gt; bool String2Word(const char *ptr, unsigned int *puiValue) { int pos = 0; char aPos[8]; unsigned int uiValue = 0; if (ptr == nullptr || *ptr == &#39;\\0&#39; || puiValue == NULL) { return false; } //这里比如“14e23”和“0x14e23”都是一样的数字 if (ptr[0] == &#39;0&#39; &amp;&amp; (ptr[1] == &#39;x&#39; || ptr[1] == &#39;X&#39;)) { ptr += 2; } while (*ptr != &#39;\\0&#39;) { if (pos &gt;= 8) { return false; } if (*ptr &gt;= &#39;0&#39; &amp;&amp; *ptr &lt;= &#39;9&#39;) { aPos[pos++] = *ptr - &#39;0&#39;; } else if (*ptr &gt;= &#39;a&#39; &amp;&amp; *ptr &lt;= &#39;f&#39;) { aPos[pos++] = *ptr - &#39;a&#39; + 10; } else if (*ptr &gt;= &#39;A&#39; &amp;&amp; *ptr &lt;= &#39;F&#39;) { aPos[pos++] = *ptr - &#39;A&#39; + 10; } else { return false; } ptr++; } for (int i = 0; i &lt; pos; i++) { uiValue = uiValue * 16 + aPos[i]; } *puiValue = uiValue; return true; } TEST(String2Word, testcase1) { const char *ptr = &quot;0x12345&quot;; unsigned int uiValue = 0; EXPECT_EQ(true, String2Word(ptr, &amp;uiValue)); EXPECT_EQ(0x12345, uiValue); } TEST(String2Word, testcase2) { const char *ptr = &quot;0x12345efc&quot;; unsigned int uiValue = 0; EXPECT_EQ(true, String2Word(ptr, &amp;uiValue)); EXPECT_EQ(0x12345efc, uiValue); } TEST(String2Word, testcase3) { const char *ptr = &quot;12345efc&quot;; unsigned int uiValue = 0; EXPECT_EQ(true, String2Word(ptr, &amp;uiValue)); EXPECT_EQ(0x12345efc, uiValue); } TEST(String2Word, testcase4) { const char *ptr = &quot;12345678&quot;; unsigned int uiValue = 0; EXPECT_EQ(true, String2Word(ptr, &amp;uiValue)); EXPECT_EQ(0x12345678, uiValue); } TEST(String2Word, testcase5) { const char *ptr = &quot;\\0&quot;; unsigned int uiValue = 0; EXPECT_EQ(false, String2Word(ptr, &amp;uiValue)); } TEST(String2Word, testcase6) { const char *ptr = &quot;0xe3.34&quot;; unsigned int uiValue = 0; EXPECT_EQ(false, String2Word(ptr, &amp;uiValue)); } TEST(String2Word, testcase7) { const char *ptr = &quot;e340fs&quot;; unsigned int uiValue = 0; EXPECT_EQ(false, String2Word(ptr, &amp;uiValue)); } int main(int argc, char *argv[]) { testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); } 总之，单元测试是软件开发中最要的一个环节，利用gtest可以方便测试我们自己编写的程序，写出程序少bug，其他gtest用法可以参考gtest附带的example，里面基本将常见的单元测试用法列举齐全了。最后附上程序猿的佛祖保佑图： _ooOoo_ o8888888o 88&quot; . &quot;88 (| -_- |) O\\ = /O ____/`---&#39;\\____ .&#39; \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| &#39;&#39;\\---/&#39;&#39; | | \\ .-\\__ `-` ___/-. / ___`. .&#39; /--.--\\ `. . __ .&quot;&quot; &#39;&lt; `.___\\_&lt;|&gt;_/___.&#39; &gt;&#39;&quot;&quot;. | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / ======`-.____`-.___\\_____/___.-`____.-&#39;====== `=---=&#39; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG","categories":[],"tags":[{"name":"软件开发","slug":"软件开发","permalink":"http://sunjunior.cn/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}]},{"title":"深圳清湖科目三路考3号线细节","slug":"cartest","date":"2019-03-31T13:37:18.000Z","updated":"2019-03-31T14:02:01.517Z","comments":true,"path":"2019/03/31/cartest/","link":"","permalink":"http://sunjunior.cn/2019/03/31/cartest/","excerpt":"","text":"清湖科目三3号线细节记录3号线路比2号线长不少，而且记忆的细节要多，因此本次主要记录3号线的操作细节，2号线比较熟悉，这里就不写了。本文按照流水线记录方式，记录考试车行驶过程中需要关注和考试的关键点。 整体原则： 停车换一档，防止3档起步，直接不合格 注意左边护栏缺口和右边某些公司大门口那些地方过马路的行人，提前做好预判 特别注意经过（真实非模拟的）公交站台时，提前观察左后视镜是否有公交马上进站了，确认之后再启动。 每次起步时，离合踩到半联动（也就是车子轻微抖动时），松刹车，稳住离合5s，车子走动3米之后再慢抬离合，防止起步熄火；万一熄火了，注意要回到空挡打火，否则不合格。 绕车一周学员在左侧门开始，逆时钟从左下，右下，右上，左上绕车身一周，注意4个角位的摄像头，用手捂住，听车内语音播报之后上车。需要注意的是，如果第一次没有驶出岗亭，在车子没有启动不合格的话，也需要下车重新绕车一周，不要忘记了，否则不合格。也就是每次都按照完整的考试项目来执行。 上车准备学员上车之后，调整好座位，系好安全带，注意所有灯光是否归位（远近交替按钮往前拨几下）。另外注意车门是否关好（没有关好的情况下，仪表盘会有一个小车子图标，门关好了是没有这个图标的）试下离合，刹车，和档位。挂档2把都顺手之后，再将档位挂到1档，找到车子离合半联动的地方，确认之后。按指纹之前，最后确认下档位是否为空挡，手刹是否拉起，安全带是否系好。没有问题之后然后按指纹准备考试。 夜间灯光模拟考试语音会播报指纹验证成功，身份验证成功之后，会播报下面开始模拟夜间灯光考试。9项中随机选择5项，其中有2项是一定是请开启前照灯，请关闭所有灯光，中间3项随机。可以这样记忆：危险报警灯1项：即路边临时停车; 交替使用远近信号灯2项（也就是左手中指往自己这侧拨4下）：通过急弯，坡路，拱桥，人行横道或者没有交通信号灯路口和超车; 远光灯1项：无照明道路行驶。其他的都是近光灯了，这样就减少了记忆工作量。灯光模拟一定要等语言播报之后再操作，不要抢答，否则不合格。 起步和靠边停车灯光模拟结束之后，语言播报请起步，这时首先踩好离合和刹车，打左转向灯，放手刹，挂一档（这3项位置恰好是逆时钟方向）。离合到半联动车子震动之后，放开脚杀，离合稳住，车子往前走了3~5米之后再慢松离合。走到网格线的时候，将左转向变为右转向灯。接下来语音会播报请靠边停车，这个时候车子方向盘中心对准箭头，来回摆正车头，注意不要幅度过大，到2个箭头中间地方的时候，踩离合和刹车，停车，回空挡，拉手刹（这个时候转向灯还是打的右转向），等待语音提示。等10s之后，语言播报请起步，又跟第一次一样，将右转向灯改为左转向灯，放手刹，挂1档，慢松离合，车子启动走动几米之后，缓慢松离合。用1档速度走到下坡路段。 驶出岗亭走下坡路段时候，不要踩离合，刹车，用1档速度下斜坡，差不多到达下坡起点时，语言提示前方路口左转，此时打左转向灯。到达水平地面时停车，重新挂1档。观察右边是否有车过来，观察左边没有车时，起步左转弯驶出岗亭，到人行横道地方再次停车，挂1档。然后开启右转向灯。注意左边是否有来车，确认没有之后，3号线走最左侧线路。然后挂2档，上3档。语音播报前方路口直行，在人行横道前面停车，重新挂1档。 掉头红路灯路况，灯闪的时候慢松离合，绿灯后，一档起步，走过路口后就可以上2档，然后上3档了。这个时候要注意左侧护栏切口处是否有行人过马路，提前做好刹车准备。一切没有异常情况下，语言提示：前方请选择合适路口掉头。在掉头前先停下来，然后观察左边是否有对向车辆过来，确认OK之后，方向盘打死，转到中间车道。 前方路口右转用一档一直往前面走，注意右边行人，随时踩刹车（不要停在厂房门口和网格线上，提前预判）。语音播报前方路口右转，开启右转向灯。到前面最后一个虚线开始处停车，观察右后视镜是否有来车。确认之后，完成变道。变道过程中极有可能转向灯跳了。要及时补上右转向灯。 在路口地方停车，然后1档起步，走过右转路口之后，将车身回正，走个3米左右，停车。 变更车道停车后，打左转向灯，方向盘左转90度，看后视镜后面是否有车辆过来，确认后，启动车辆完成变更车道。然后用1档往前走，前面有个（模拟的）公交站台，在公交站台牌子前面1米左右的地方停车。然后1档起步。起步完了换到2档，然后上到3档，前面有个学校区域，只要车速不超过30码就可以了。语言提示前方路况左转，开启左转向灯，到前面三岔路口的人行横道前面停车，挂回1档。 超车项目绿灯之后，车子起步，左转到最右侧车道，一直往前走，语音会播报请超越前方车辆，停车，打左转向灯，挂一档，方向盘左打90度。车身摆正之后，打右转向灯，一直往前走，然后语音播报已超越车辆，车子停下来，然后打右转向灯，方向盘右打90度，返回原右侧车道之后摆正车身。注意变更到左边车道之后，不要抢语音，等待报了超越车辆之后再返回原车道。 加减档操作然后前面走个几米找个无项目的地方变更车道，变更到最左侧车道（注意不要把车停到厂房门口或者网格线上），变更完车道之后，以1档的速度到前面人行横道前面停车。这个就是2号线掉头的地方，确认无对向车辆掉头之后，走过路口，挂2档，以接近20码的速度行驶，然后前面会有一个公交站台，这个地方会有语言提示，请升到3档，这个时候踩油门，及时完成换挡即可。驶过拐弯路段之后，语言提示前方路口直行，车子以3档25码左右的速度在前面红路灯人行横道前面停车，换成1档起步即可。 直线行驶过了路口之后，车身回正，前面语音会播报请保持直线行驶，这个时候手要一直握住方向盘，不要紧握了。然后方向盘微微向两侧微调。方向盘中心可以远方向和前方路况维也纳酒店中间的电线杆成一条直线。过了左侧护栏缺口之后，直线行驶结束。然后开启左转向灯，进入路口等待红绿灯。这里要特别注意红绿灯，确认是红灯之后，还要注意前方是否有右转弯车辆，确认后左转到中间车道，用1档的速度行驶就可以了。只需要注意缺口的地方是否有行人，随时停车。 变更车道红绿灯为绿灯时，观察右边车辆情况，然后左转方向，将车驶入到最右侧车道，一直往前走。听到语音播报请变更车道后，车子停下来，然后打左转向灯，方向盘左转90度，看左边后视镜无车辆过来，完成变道。变道之后，远处观察下，注意前面无行人之后，挂2档，上3档，语音提示前方路况左转，打左转向灯，以25~30码速度一直往前开，在前面十字路口人行横道前面停车。重新挂1档。 会车观察红绿灯，绿灯的时候，注意右边直行车辆，确认没有无障碍之后，将车驶入到最中间车道，然后语音播报会车，这个时候以1档速度会车。这个时候一直往前走，听到会车完成之后，然后在一直走直线（为了防止压到厂房门口的下水道盖子）。到厂房门口的时候，可以开启右转向灯了。 右边停车前面走了一段距离之后，会听到语音播报，前方请选择合适地点停车，此时一直往前走，语音还会播报一次请靠边停车，这个时候只需要在终点的那块牌子旁边停车即可。停车之后，挂空挡拉手刹。等待系统播报成绩,播报之后再解开安全带。考试结束。","categories":[],"tags":[{"name":"驾考经验","slug":"驾考经验","permalink":"http://sunjunior.cn/tags/%E9%A9%BE%E8%80%83%E7%BB%8F%E9%AA%8C/"}]},{"title":"利用shadowsocks上外网","slug":"shadowsocks","date":"2019-03-21T14:11:31.000Z","updated":"2020-05-04T00:44:41.718Z","comments":true,"path":"2019/03/21/shadowsocks/","link":"","permalink":"http://sunjunior.cn/2019/03/21/shadowsocks/","excerpt":"","text":"本人作为一名IT工作者，对于了解国内外先进的黑科技是有必要的。由于谷歌在搜索体验上吊打百度，因此利用谷歌来获取额外的信息是非常有值得的。可是，国内谷歌被墙，需要上外网必须通过VPN，因此找一款合适的VPN也需要在市场上各类VPN中找到靠谱的那一款。 这里我们找到了一款比较靠谱的VPN软件，这是一款Google chrome插件，叫Ghelper，在网上搜索该款插件之后，安装chrome插件，就可以用chrome浏览器上网了。如果没有付费，一般也能上谷歌搜索和谷歌邮箱，其他的网站就屏蔽了，比如Facebook，Twitter，YouTube等等。按照插件付费步骤付费（一个月也就16元人民币，不贵，一顿饭钱而已）之后，就可以享受科学上网的便利了。这里简单地看下Ghelper界面配置情况，如下图所示 其实，只需要我们购买付费服务之后，就可以顺畅地上类似youtube视频网站了： 此外，我们需要在手机设备一栏中，新增服务，加密方式一般选择aes-256-cfb方式即可。这样新增的服务中会出现VPN所有信息，包括主机地址，服务器端口，加密方式及密钥。 这里我创建了3个服务地址，方便手机软件轮流使用，防止某一线路不通导致无法上网： 打开手机安装的shadowsocks软件，右上角有个加号按钮，点击之后，如下图所示，这里我们既可以用二维码扫描方式配置（就是上图中模糊的二维码），也可以手动配置，效果是一样的，这样我们用手动设置： 进入手动设置配置界面，将Ghelper中手机设置中的某一个服务配置信息拿过来，进行一一对应填写上，确认就可以科学上网了： 这样我们就可以顺利在手机上上网了，每次使用需要VPN连接的软件时，我们首先需要进入到shadowsocks软件下，点击连接后，状态显示已经连接，退出来之后，就可以愉快地上Google 地图，Youtube，twiiter等客户端。","categories":[],"tags":[{"name":"VPN科学上网","slug":"VPN科学上网","permalink":"http://sunjunior.cn/tags/VPN%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}]},{"title":"archlinux升级系统之后无法启动问题","slug":"arch-repair","date":"2018-10-07T01:39:43.000Z","updated":"2020-05-04T00:38:30.190Z","comments":true,"path":"2018/10/07/arch-repair/","link":"","permalink":"http://sunjunior.cn/2018/10/07/arch-repair/","excerpt":"","text":"本人用的Linux系统版本是archlinux系统，这几年来一直用命令 pacman -Syu滚动升级到最新版本，还没有出现滚挂的问题。这两天用命令全量升级之后，重新电脑，发现系统开启不了了，但是在恢复模式下能启动进入系统界面。如果在正常模式下启动，会提示无法找到UUID： 我在恢复模式下进入系统之后，查看是否我的fstab配置问题，经过确认之后，确认配置没有啥问题。 经过几番折腾和网上搜索解决方案，在Stack Exchange上找到了一篇帖子“Unable to find root device” on a fresh ArchLinux install，很好的解决了这个问题。文中说道，Linux由于默认镜像文件中缺少block mkinitcpio hook（负责块设备），Linux启动时无法检测到任何驱动器（比如/dev/sda1,/dev/sdb1等等）。因为在配置文件/etc/mkinitcpio.conf中，block放到了autodetect之后，只需要调换一下位置，重新打包内核就可以了。 修改之前的配置： 1HOOKS=(base udev autodetect modconf block filesystems keyboard fsck) 修改之后的配置： 1HOOKS=(base udev block autodetect modconf filesystems keyboard fsck) 配置OK之后，重新执行下面命令产生initramfs，永久地修复了该问题。 1mkinitcpio -p linux","categories":[],"tags":[{"name":"Linux系统修复","slug":"Linux系统修复","permalink":"http://sunjunior.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8D/"}]},{"title":"安卓手机如何变成一台便携式Linux主机","slug":"laptop","date":"2018-10-05T01:49:58.000Z","updated":"2020-05-04T00:42:54.939Z","comments":true,"path":"2018/10/05/laptop/","link":"","permalink":"http://sunjunior.cn/2018/10/05/laptop/","excerpt":"","text":"​ 程序员出门在外，经常会带着笔记本电脑学习。然而，笔记本电脑也有很多不便利的地方，比如重量较重，普通的笔记本一般也有2.5KG左右，长期背或者挎在身上，也是不小的负担。另外笔记本比较耗电，一般笔记本支撑3~5小时左右就差不多没有电了。而在外面的读书室或者图书馆也很少有供电的插头提供给读者。这里我们将普通的安卓手机打造成一台便携式Linux主机，就会解决以上的问题。安卓手机一般耗电较少，如果觉得不够，带上一个充电宝，基本可以支撑一天左右的时间。不过，安卓手机作为开发主机也有其缺点：首先只能用控制台进行程序开发，无法用图形界面，可以简单理解为一台无图形界面的Linux服务器。我们可以通过ssh协议远程登录上这台主机上去进行各类软件开发；另外一个缺点就是屏幕太小，如果手机没有达到5英寸以上，一般也不适合开发，因此推荐DIY的安卓手机屏幕在5.5英寸以上（最少5英寸）就可以了。考虑到市面上大部分安卓手机都在5英寸以上，因此都可以DIY成一台Linux开发主机。本人之前在博文《安卓手机安装Archlinux系统搭建web服务》中谈到了如何将安卓手机变成一台web服务器。这里我们将基于该博文，将更多地DIY细节展现出来，方便感兴趣的同学参考。先放上DIY成功后的一张安卓主机图片，这样是不是很炫酷，而且基本也满足了日常的开发要求。 ​ 下面重点介绍一下如何打造成满足日常开发的便携式Linux主机，我们知道安卓手机后台就是运行的Linux操作系统，因此只需要进入到该Linux操作系统，做相关配置之后就可以满足要求了。首先我们需要在安卓手机上安装如下几款软件，为后面DIY做好铺垫（如下图）： 手机ROOT软件，这个是DIY的前提，如果手机没有ROOT，则无法获取安卓手机后台Linux的绝对控制权，对里面的文件和目录等无法做修改的。普通用户下的文件权限一般是只读的。这里我DIY安卓手机中用的是360超级root软件，当然也可以用其他root软件代替。 模拟控制台软件，安装一个可以和后台Linux交互的模拟终端。这里安装一个终端模拟器，方便手机root之后，登录手机后台的linux系统，对手机做相关的配置修改。这里还需要安装一个SSH登录软件JuiceSSH，该软件相比终端模拟器而言，支持各种不同Linux终端配色方案，比如xterm, Linux,screen-256color,xterm-256color等等，使得我们的终端颜色更为丰富，为后续使用oh my zsh和vim, tmux等软件做铺垫。 安装BusyBox Pro安卓版的软件包，将其安装到/system/xbin目录下，后面的配置启动脚本将该目录下的busybox作为环境变量导出。BusyBox是标准Linux工具的一个单个可执行实现，一般用于嵌入式设备，比如mp4，安卓手机，平板电脑等等。BusyBox包含了一些简单的工具，例如cat和 ls，还包含了一些更大、更复杂的工具，例如grep、find、mount以及telnet等等。 ​ 此外为了在手机上做开发，我们还需要一套蓝牙键盘（鼠标用不上，因为我们用的是vim开发），一个手机支撑架，一款flash存储卡。由于手机自带的键盘码字能力太弱了，因此需要蓝牙键盘来提升打字速度；另外手机支撑架可以将手机立起来，方便我们观看屏幕。SD存储卡是存放我们的archlinux系统镜像文件的，考虑到该镜像文件内部需要安装各类软件，因此建议内存大小最少在16G以上。同时我们将制作好的archlinux.img镜像文件存放到外置SD卡上，方便后面扩容和数据安全。现在我们就开始配置和安装Linux系统了。实际上，我们DIY的系统只是替换了手机原本的文件系统，内核部分由于bootloader的限制，无法实现替换，也就是说在手机老的内核上运行最新的文件系统。我们这里利用了Linux系统的chroot命令，将一个文件系统镜像挂载到现有的系统下，利用现有系统资源，chroot到我们DIY的系统上。这样我们就可以利用最新的文件系统来实现下载安装，配置对应的软件了。chroot命令常用于恢复系统，比如PC机上的grub被删除了，导致无法加载操作系统。这个时候一般用一张Linux live启动CD光盘进入系统，将电脑原有的文件系统挂载到当前系统之上，chroot到原有文件系统上，则可以恢复grub了，具体可以参考我的另外一篇博文《fedora 18 使用LiveCD修复grub2引导》。现在我们开始编写启动脚本，脚本的主要作用就是上面讲述的，如何创建一个loop设备挂载当前文件系统，进入到当前的文件系统，此外，我们还需要启动一系列服务程序，比如sshd服务，ftp服务等等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122############################################ This is a function we use to stop the ## script in case of errors ############################################error_exit() &#123; echo \"Error: $1\" exit 1&#125;############################################ Set up variables ############################################export bbox=/system/xbin/busybox #这里我们导入busybox的路径，方便我们执行各种bash命令export usermounts=android # Base folder all user mounts are done in, should be moved to app laterexport imgfile=$(dirname $0)/archlinux.img # Default image file, another can be set by using an argumentexport bin=/system/bin export mnt=/data/local/mnt #挂载archlinux.img镜像文件的根路径export USER=rootif [[ ! -d $mnt ]]; then mkdir $mnt; fiexport PATH=$bin:/usr/bin:/usr/local/bin:/usr/sbin:/bin:/usr/local/sbin:/usr/games:$PATHexport TERM=linuxexport HOME=/root################################# Find and read config file ## or use defaults if not found #################################use_swap=no #这里不用创建交换分区，实际上这段创建swap分区的脚本没有用上cfgfile=$imgfile.config # Default config file if not specifiedif [ -f $imgfile.config ]; then source $imgfile.configfi############################################ Set Swap up if wanted ## ############################################if [ $use_swap == yes ]; then if [ -f $imgfile.swap ]; then echo \"Swap file found, using file\" echo \"Turning on swap (if it errors here you do not have swap support\" swapon $imgfile.swap else echo \"Creating Swap file\" dd if=/dev/zero of=$imgfile.swap bs=1048576 count=1024 mkswap $imgfile.swap echo \"Turning on swap (if it errors here you do not have swap support\" swapon $imgfile.swap fifi############################################ Set up loop device and mount image ############################################echo -n \"Checking loop device... \" if [ -b /dev/block/loop255 ]; then echo \"FOUND\"else echo \"MISSING\" # Loop device not found so we create it and verify it was actually created echo -n \"Creating loop device... \" $bbox mknod /dev/block/loop255 b 7 255 if [ -b /dev/block/loop255 ]; then echo \"OK\" else echo \"FAILED\" error_exit \"Unable to create loop device!\" fifi$bbox losetup /dev/block/loop255 $imgfile #这里才是真正的创建loop device的地方if [ $? -ne 0 ];then error_exit \"Unable to attach image to loop device! (Image = $imgfile)\"; fi$bbox mount -t ext4 /dev/block/loop255 $mnt #指定挂载文件系统类型为ext4if [ $? -ne 0 ];then error_exit \"Unable to mount the loop device!\"; fi############################################################ 下面部分为挂载一些必要的分区，比如/dev /dev/pts /proc /sys等等###########################################################$bbox mount -o bind /dev $mnt/devif [ $? -ne 0 ]; then error_exit \"Unable to mount $mnt/dev!\"; fiif [[ ! -d $mnt/dev/pts ]]; then $bbox mkdir -p $mnt/dev/pts; fi$bbox mount -t devpts devpts $mnt/dev/ptsif [ $? -ne 0 ]; then error_exit \"Unable to mount $mnt/dev/pts!\"; fi$bbox mount -t proc proc $mnt/procif [ $? -ne 0 ]; then error_exit \"Unable to mount $mnt/proc!\"; fi$bbox mount -o bind /sys $mnt/sysif [ $? -ne 0 ]; then error_exit \"Unable to mount $mnt/sys!\"; fi$bbox mount -o bind /sdcard $mnt/sdcardif [ $? -ne 0 ]; then error_exit \"Unable to bind $mnt/sdcard!\"; fiif [[ ! -d $mnt/root/cfg ]]; then mkdir $mnt/root/cfg; fi$bbox mount -o bind $(dirname $imgfile) $mnt/root/cfg$bbox mount -o bind /sys/fs/selinux $mnt/selinux############################################ Checks if you have a external sdcard ## and mounts it if you do ############################################if [ -d /storage/sdcard1 ]; then $bbox mount -o bind /storage/sdcard1 $mnt/external_sdfi############################################ Sets up network forwarding ############################################$bbox sysctl -w net.ipv4.ip_forward=1if [ $? -ne 0 ];then error_exit \"Unable to forward network!\"; fi#####################################################################将当前挂载的文件系统作为系统的根文件系统，同时指定init.sh脚本来初始化相应服务 #####################################################################$bbox chroot $mnt /root/init.sh $(basename $imgfile) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#!/bin/bash############################################## Script by Zachary Powell (zacthespack) ## Fixes to allow running as a non-root user ## by Barry flanagan &lt;barry@flanagan.ie&gt; ##############################################export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/sbinexport TERM=xterm #linuxexport HOME=/root################################# Find and read config file ## or use defaults if not found #################################run_ssh=yesrun_ddns=askresolution=askcfgfile=/root/cfg/linux.config # Default config file if not specifiedif [ -f /root/cfg/.running_config ]; then source /root/cfg/.running_configfiif [ $# -ne 0 ]; then cfgfile=/root/cfg/$1.config if [ -f $cfgfile ]; then echo \"Using config file $cfgfile\" else echo \"Config file not found, using defaults!($cfgfile)\" fifiif [ -f $cfgfile ]; then source $cfgfile echo \"cfgfile=$cfgfile\" &gt; /root/cfg/.running_config # To make it possible to chroot into a mounted image from the app echo \"Config file loaded\"else if [ -f /root/cfg/.running_config ]; then rm /root/cfg/.running_config fifi############################################## Fixes for first boot including setting up ## User ##############################################if [ ! -f /root/DONOTDELETE.txt ] then echo \"Starting first boot setup.......\" chmod a+rw /dev/null chmod a+rw /dev/ptmx chmod 1777 /tmp chmod 1777 /dev/shm chmod +s /usr/bin/sudo groupadd -g 3001 android_bt groupadd -g 3002 android_bt-net groupadd -g 3003 android_inet groupadd -g 3004 android_net-raw mkdir /var/run/dbus chown dbus.dbus /var/run/dbus chmod 755 /var/run/dbus usermod -a -G android_bt,android_bt-net,android_inet,android_net-raw dbus echo \"shm /dev/shm tmpfs nodev,nosuid,noexec 0 0\" &gt;&gt; /etc/fstab cd /root tar cf - .vnc |(cd /home/archlinux ; tar xf -) chown -R archlinux.users /home/archlinux echo echo \"Now give your user account (named archlinux) a password\" echo echo \"Please enter the new password below\" echo passwd archlinux usermod -a -G admin archlinux usermod -a -G android_bt,android_bt-net,android_inet,android_net-raw archlinux # Fix for sdcard read/write permissions by Barry flanagan chown archlinux /external_sd/ groupadd -g 1015 sdcard-rw usermod -a -G sdcard-rw archlinux echo \"boot set\" &gt;&gt; /root/DONOTDELETE.txtfi############################################ Tidy up previous LXDE and DBUS sessions ############################################rm /tmp/.X* &gt; /dev/null 2&gt;&amp;1rm /tmp/.X11-unix/X* &gt; /dev/null 2&gt;&amp;1rm /root/.vnc/localhost* &gt; /dev/null 2&gt;&amp;1rm /var/run/dbus/pid &gt; /dev/null 2&gt;&amp;1rm /var/run/reboot-required* &gt; /dev/null 2&gt;&amp;1############################################################# enable workaround for upstart dependent installs ## in chroot'd environment. this allows certain packages ## that use upstart start/stop to not fail on install. ## this means they will have to be launched manually though #############################################################dpkg-divert --local --rename --add /sbin/initctl &gt; /dev/null 2&gt;&amp;1ln -s /bin/true /sbin/initctl &gt; /dev/null 2&gt;&amp;1##workaroundif [ ! -d /dev/fd ]; then ln -s /proc/self/fd /dev/fdfiif [ ! -d /dev/shm ]; then mkdir /dev/shm chmod 1777 /dev/shmfi################################################################ Ask if ssh should start if the setting don't exists ################################################################if [ $run_ssh = ask ]; then echo \"Start SSH server? (y/n)\" read answer if [ $answer = y ]; then run_ssh=yes else run_ssh=no fifiif [ $run_ddns = ask ]; then echo \"Start Obay ddns server? (y/n)\" read answer if [ $answer = y ]; then run_ddns=yes else run_ddns=no fifi############################################# If SSH server should start we do it here ##############################################openssh服务，安装之后可以远程ssh登录到此设备if [ $run_ssh = yes ]; then /usr/sbin/sshdfi#花生壳服务，用于内网穿透，使得外网也能访问到该手机if [ $run_ddns = yes ]; then /usr/sbin/phddns startfi#启动http服务，需要安装apache之后，脚本才能生效apache=$(ps aux | grep httpd | grep -v grep)if [ -n \"$apache\" ]then echo \"httpd server is running\"else echo \"httpd is starting now...\" /usr/bin/httpdfi#启动mysql服务，需要安装MariaDB(mysql)之后，脚本才能生效mysqld=$(ps aux | grep mysqld | grep -v grep)if [ -n \"$mysqld\" ]then echo \"mysqld server is running\"else echo \"mysqld is starting now...\" /usr/bin/mysqld -u root &amp;fi#启动ftp服务，需要安装bftpd之后脚本才能生效bftpd=$(ps aux | grep bftpd | grep -v grep)if [ -n \"$bftpd\" ]then echo \"bftpd server is running\"else echo \"bftpd is starting now...\" /usr/bin/bftpd -d &amp;fi######################################################################### If not the config file exist we ask the user if he want to create it #########################################################################if [ ! -f $cfgfile ]; then echo \"Save settings as defaults? (y/n) (You can always change it later in the app)\" read answer if [ $answer = y ]; then echo \"Config saved to $cfgfile\" echo \"resolution=$resolution\" &gt; $cfgfile echo \"run_ssh=$run_ssh\" &gt;&gt; $cfgfile echo \"run_ddns=$run_ddns\" &gt;&gt; $cfgfile echo \"cfgfile=$cfgfile\" &gt; /root/cfg/.running_config # To make it possible to chroot into a mounted image from the app fifiechoecho \"To shut down the Linux environment, just enter 'exit' at this terminal - and WAIT for all shutdown routines to finish!\"echo################################################################ Spawn and interactive shell - this effectively halts script ## execution until the spawning shell is exited (i.e. you want ################################################################/bin/zsh -i #这里初始是/bin/bash -i 后面安装了zsh之后，修改为zsh ​ 脚本启动完成之后，这时，我们会进入到新的文件系统中。我们需要配置archlinux arm的镜像源来及时更新当前软件。这里我们用清华的镜像源。需要注意的是，我们这里一定要选择arm版本的镜像源，一般的都是X86的镜像源。 ​ 由于是在终端上进行开发，因此我们需要安装一系列开发软件，比如git、svn、Java、Scala、Python、Perl、racket（lisp）、gcc、cmake等工具，这里最重要的是配置和安装vim和tmux这2个工具。因为在终端上开发，我们选择的最佳开发工具只能是基于控制台的，当前选择的主流就是vim和emacs，这里用我们熟悉的vim来进行开发。我们将vim打造成终端控制台下最强IDE。另外tmux是一款终端复用工具，一般用于功能联调时使用，比如开发了一款C/S服务程序，需要实时查看状态，这时我们可以用tmux创建2个session，一个用于客户端，一个用于服务端，来回切换session，用来观察输出结果。vim安装之后需要安装各类插件来支持语法高亮，智能补全等功能。这里我们直接用github上的前人已经配置好vim，这里具体可以参考链接： https://github.com/yangyangwithgnu/use_vim_as_ide。 本DIY安卓手机上的.vimrc文件配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525\" 定义快捷键的前缀，即 &lt;Leader&gt;let mapleader=\";\"\" &gt;&gt;\" 文件类型侦测\" 开启文件类型侦测filetype on\" 根据侦测到的不同类型加载对应的插件filetype plugin on\" &lt;&lt;\" &gt;&gt;\" vim 自身（非插件）快捷键\" 定义快捷键到行首和行尾nmap LB 0nmap LE $\" 设置快捷键将选中文本块复制至系统剪贴板vnoremap &lt;Leader&gt;y \"+y\" 设置快捷键将系统剪贴板内容粘贴至vimnmap &lt;Leader&gt;p \"+p\" 定义快捷键关闭当前分割窗口nmap &lt;Leader&gt;q :q&lt;CR&gt;\" 定义快捷键保存当前窗口内容nmap &lt;Leader&gt;w :w&lt;CR&gt;\" 定义快捷键保存所有窗口内容并退出 vimnmap &lt;Leader&gt;WQ :wa&lt;CR&gt;:q&lt;CR&gt;\" 不做任何保存，直接退出 vimnmap &lt;Leader&gt;Q :qa!&lt;CR&gt;\" 设置快捷键遍历子窗口\" 依次遍历nnoremap nw &lt;C-W&gt;&lt;C-W&gt;\" 跳转至右方的窗口nnoremap &lt;Leader&gt;lw &lt;C-W&gt;l\" 跳转至方的窗口nnoremap &lt;Leader&gt;hw &lt;C-W&gt;h\" 跳转至上方的子窗口nnoremap &lt;Leader&gt;kw &lt;C-W&gt;k\" 跳转至下方的子窗口nnoremap &lt;Leader&gt;jw &lt;C-W&gt;j\" 定义快捷键在结对符之间跳转nmap &lt;Leader&gt;M %\" &lt;&lt;\" 让配置变更立即生效autocmd BufWritePost $MYVIMRC source $MYVIMRC\" &gt;&gt;\" 其他\" 开启实时搜索功能set incsearch\" 搜索时大小写不敏感set ignorecase\" 关闭兼容模式set nocompatible\" vim 自身命令行模式智能补全set wildmenu\" &lt;&lt;\" &gt;&gt;&gt;&gt;\" 插件安装\" vundle 环境设置filetype offset rtp+=~/.vim/bundle/Vundle.vim\" vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间call vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'altercation/vim-colors-solarized'Plugin 'tomasr/molokai'Plugin 'vim-scripts/phd'Plugin 'Lokaltog/vim-distinguished'Plugin 'Lokaltog/vim-powerline'Plugin 'octol/vim-cpp-enhanced-highlight'Plugin 'nathanaelkane/vim-indent-guides'Plugin 'derekwyatt/vim-fswitch'Plugin 'kshenoy/vim-signature'Plugin 'vim-scripts/BOOKMARKS--Mark-and-Highlight-Full-Lines'Plugin 'majutsushi/tagbar'Plugin 'vim-scripts/indexer.tar.gz'Plugin 'vim-scripts/DfrankUtil'Plugin 'vim-scripts/vimprj'Plugin 'dyng/ctrlsf.vim'Plugin 'terryma/vim-multiple-cursors'Plugin 'scrooloose/nerdcommenter'Plugin 'vim-scripts/DrawIt'Plugin 'SirVer/ultisnips' Plugin 'Valloric/YouCompleteMe'Plugin 'derekwyatt/vim-protodef'Plugin 'scrooloose/nerdtree'Plugin 'gcmt/wildfire.vim'Plugin 'sjl/gundo.vim'Plugin 'Lokaltog/vim-easymotion'Plugin 'suan/vim-instant-markdown'Plugin 'lilydjwg/fcitx.vim'Plugin 'jiangmiao/auto-pairs'Plugin 'bhurlow/vim-parinfer'Plugin 'derekwyatt/vim-scala'Plugin 'vim-scripts/c.vim'Plugin 'ludovicchabant/vim-gutentags'Plugin 'skywind3000/asyncrun.vim'\" 插件列表结束call vundle#end()filetype plugin indent on\" &lt;&lt;&lt;&lt;\" 配色方案set background=dark\"colorscheme solarizedcolorscheme molokai\"colorscheme phd\"colorscheme desert\"colorscheme distinguished\" &gt;&gt;\" 营造专注气氛\" 禁止光标闪烁set gcr=a:block-blinkon0\" 禁止显示滚动条set guioptions-=lset guioptions-=Lset guioptions-=rset guioptions-=R\" 禁止显示菜单和工具条set guioptions-=mset guioptions-=T\" 将外部命令 wmctrl 控制窗口最大化的命令行参数封装成一个 vim 的函数fun! ToggleFullscreen() call system(\"wmctrl -ir \" . v:windowid . \" -b toggle,fullscreen\")endf\" 全屏开/关快捷键\"map &lt;silent&gt; &lt;F11&gt; :call ToggleFullscreen()&lt;CR&gt;\"\" 启动 vim 时自动全屏\"autocmd VimEnter * call ToggleFullscreen()\" &lt;&lt;set shortmess=atI\" &gt;&gt;\" 辅助信息\" 总是显示状态栏set laststatus=2\" 显示光标当前位置set ruler\" 开启行号显示set number\" 高亮显示当前行/列set cursorlineset cursorcolumn\" 高亮显示搜索结果set hlsearch\" &lt;&lt;\" &gt;&gt;\" 其他美化\" 设置 gvim 显示字体set guifont=YaHei\\ Consolas\\ Hybrid\\ 12\" 禁止折行set nowrap\" 设置状态栏主题风格let g:Powerline_colorscheme='solarized256'\" &lt;&lt;\" &gt;&gt;\" 语法分析\" 开启语法高亮功能syntax enable\" 允许用指定语法高亮配色方案替换默认方案syntax on\" &lt;&lt;\" &gt;&gt;\" 缩进\" 自适应不同语言的智能缩进filetype indent on\" 将制表符扩展为空格set expandtab\" 设置编辑时制表符占用空格数set tabstop=4\" 设置格式化时制表符占用空格数set shiftwidth=4\" 让 vim 把连续数量的空格视为一个制表符set softtabstop=4\" 缩进可视化插件 Indent Guides\" 随 vim 自启动let g:indent_guides_enable_on_vim_startup=1\" 从第二层开始可视化显示缩进let g:indent_guides_start_level=2\" 色块宽度let g:indent_guides_guide_size=1\" 快捷键 i 开/关缩进可视化nmap &lt;silent&gt; &lt;Leader&gt;i &lt;Plug&gt;IndentGuidesToggle\" &lt;&lt;\" &gt;&gt;\" 代码折叠\" 基于缩进或语法进行代码折叠\"set foldmethod=indentset foldmethod=syntax\" 启动 vim 时关闭折叠代码set nofoldenable\" &lt;&lt;\" &gt;&gt;\" 接口与实现快速切换\" *.cpp 和 *.h 间切换nmap &lt;silent&gt; &lt;Leader&gt;sw :FSHere&lt;cr&gt;\" &lt;&lt;\" &gt;&gt;\" 代码收藏\" 自定义 vim-signature 快捷键let g:SignatureMap = &#123; \\ 'Leader' : \"m\", \\ 'PlaceNextMark' : \"m,\", \\ 'ToggleMarkAtLine' : \"m.\", \\ 'PurgeMarksAtLine' : \"m-\", \\ 'DeleteMark' : \"dm\", \\ 'PurgeMarks' : \"mda\", \\ 'PurgeMarkers' : \"m&lt;BS&gt;\", \\ 'GotoNextLineAlpha' : \"']\", \\ 'GotoPrevLineAlpha' : \"'[\", \\ 'GotoNextSpotAlpha' : \"`]\", \\ 'GotoPrevSpotAlpha' : \"`[\", \\ 'GotoNextLineByPos' : \"]'\", \\ 'GotoPrevLineByPos' : \"['\", \\ 'GotoNextSpotByPos' : \"mn\", \\ 'GotoPrevSpotByPos' : \"mp\", \\ 'GotoNextMarker' : \"[+\", \\ 'GotoPrevMarker' : \"[-\", \\ 'GotoNextMarkerAny' : \"]=\", \\ 'GotoPrevMarkerAny' : \"[=\", \\ 'ListLocalMarks' : \"ms\", \\ 'ListLocalMarkers' : \"m?\" \\ &#125;\" &lt;&lt;\" &gt;&gt;\" 标签列表\" 设置 tagbar 子窗口的位置出现在主编辑区的左边let tagbar_left=1\" 设置显示／隐藏标签列表子窗口的快捷键。速记：identifier list by tagnnoremap &lt;Leader&gt;ilt :TagbarToggle&lt;CR&gt;\" 设置标签子窗口的宽度let tagbar_width=32\" tagbar 子窗口中不显示冗余帮助信息let g:tagbar_compact=1\" 设置 ctags 对哪些代码标识符生成标签let g:tagbar_type_cpp = &#123; \\ 'ctagstype' : 'c++', \\ 'kinds' : [ \\ 'c:classes:0:1', \\ 'd:macros:0:1', \\ 'e:enumerators:0:0', \\ 'f:functions:0:1', \\ 'g:enumeration:0:1', \\ 'l:local:0:1', \\ 'm:members:0:1', \\ 'n:namespaces:0:1', \\ 'p:functions_prototypes:0:1', \\ 's:structs:0:1', \\ 't:typedefs:0:1', \\ 'u:unions:0:1', \\ 'v:global:0:1', \\ 'x:external:0:1' \\ ], \\ 'sro' : '::', \\ 'kind2scope' : &#123; \\ 'g' : 'enum', \\ 'n' : 'namespace', \\ 'c' : 'class', \\ 's' : 'struct', \\ 'u' : 'union' \\ &#125;, \\ 'scope2kind' : &#123; \\ 'enum' : 'g', \\ 'namespace' : 'n', \\ 'class' : 'c', \\ 'struct' : 's', \\ 'union' : 'u' \\ &#125;\\ &#125;\" &lt;&lt;\" &gt;&gt;\" 代码导航 \" 基于标签的代码导航\" 设置插件 indexer 调用 ctags 的参数\" 默认 --c++-kinds=+p+l，重新设置为 --c++-kinds=+l+p+x+c+d+e+f+g+m+n+s+t+u+v\" 默认 --fields=+iaS 不满足 YCM 要求，需改为 --fields=+iaSllet g:indexer_ctagsCommandLineOptions=\"--c++-kinds=+l+p+x+c+d+e+f+g+m+n+s+t+u+v --fields=+iaSl --extra=+q\"let g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/.ycm_extra_conf.py'\" 正向遍历同名标签nmap &lt;Leader&gt;tn :tnext&lt;CR&gt;\" 反向遍历同名标签nmap &lt;Leader&gt;tp :tprevious&lt;CR&gt;\" 基于语义的代码导航nnoremap &lt;leader&gt;jc :YcmCompleter GoToDeclaration&lt;CR&gt;\" 只能是 #include 或已打开的文件nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinition&lt;CR&gt;\" &lt;&lt;\" &gt;&gt;\" 查找\" 使用 ctrlsf.vim 插件在工程内全局查找光标所在关键字，设置快捷键。快捷键速记法：search in projectnnoremap &lt;Leader&gt;sp :CtrlSF&lt;CR&gt;\" &lt;&lt;\" &gt;&gt;\" 内容替换\" 快捷替换let g:multi_cursor_next_key='&lt;S-n&gt;'let g:multi_cursor_skip_key='&lt;S-k&gt;'\" 精准替换\" 替换函数。参数说明：\" confirm：是否替换前逐一确认\" wholeword：是否整词匹配\" replace：被替换字符串function! Replace(confirm, wholeword, replace) wa let flag = '' if a:confirm let flag .= 'gec' else let flag .= 'ge' endif let search = '' if a:wholeword let search .= '\\&lt;' . escape(expand('&lt;cword&gt;'), '/\\.*$^~[') . '\\&gt;' else let search .= expand('&lt;cword&gt;') endif let replace = escape(a:replace, '/\\&amp;~') execute 'argdo %s/' . search . '/' . replace . '/' . flag . '| update'endfunction\" 不确认、非整词nnoremap &lt;Leader&gt;R :call Replace(0, 0, input('Replace '.expand('&lt;cword&gt;').' with: '))&lt;CR&gt;\" 不确认、整词nnoremap &lt;Leader&gt;rw :call Replace(0, 1, input('Replace '.expand('&lt;cword&gt;').' with: '))&lt;CR&gt;\" 确认、非整词nnoremap &lt;Leader&gt;rc :call Replace(1, 0, input('Replace '.expand('&lt;cword&gt;').' with: '))&lt;CR&gt;\" 确认、整词nnoremap &lt;Leader&gt;rcw :call Replace(1, 1, input('Replace '.expand('&lt;cword&gt;').' with: '))&lt;CR&gt;nnoremap &lt;Leader&gt;rwc :call Replace(1, 1, input('Replace '.expand('&lt;cword&gt;').' with: '))&lt;CR&gt;\" &lt;&lt;\" 模板补全\" UltiSnips 的 tab 键与 YCM 冲突，重新设定let g:UltiSnipsSnippetDirectories=[\"mysnippets\"]let g:UltiSnipsExpandTrigger=\"&lt;leader&gt;&lt;tab&gt;\"let g:UltiSnipsJumpForwardTrigger=\"&lt;leader&gt;&lt;tab&gt;\"let g:UltiSnipsJumpBackwardTrigger=\"&lt;leader&gt;&lt;s-tab&gt;\"\" &gt;&gt;\" YCM 补全\" YCM 补全菜单配色\" 菜单highlight Pmenu ctermfg=2 ctermbg=3 guifg=#005f87 guibg=#EEE8D5\" 选中项highlight PmenuSel ctermfg=2 ctermbg=3 guifg=#AFD700 guibg=#106900\" 补全功能在注释中同样有效let g:ycm_complete_in_comments=1\" 允许 vim 加载 .ycm_extra_conf.py 文件，不再提示let g:ycm_confirm_extra_conf=0\" 开启 YCM 标签补全引擎let g:ycm_collect_identifiers_from_tags_files=0\"\" 引入 C++ 标准库 tags\"set tags+=/data/misc/software/app/vim/stdcpp.tags\"set tags+=/data/misc/software/app/vim/sys.tagsset tags=./.tags;,.tags\" YCM 集成 OmniCppComplete 补全引擎，设置其快捷键inoremap &lt;leader&gt;; &lt;C-x&gt;&lt;C-o&gt;\" 补全内容不以分割子窗口形式出现，只显示补全列表set completeopt-=preview\" 从第一个键入字符就开始罗列匹配项let g:ycm_min_num_of_chars_for_completion=1\" 禁止缓存匹配项，每次都重新生成匹配项let g:ycm_cache_omnifunc=0\" 语法关键字补全let g:ycm_seed_identifiers_with_syntax=1\" &lt;&lt; \" &gt;&gt;\" 由接口快速生成实现框架\" 成员函数的实现顺序与声明顺序一致let g:disable_protodef_sorting=1\" &lt;&lt;\" &gt;&gt;\" 库信息参考 \" 启用:Man命令查看各类man信息source $VIMRUNTIME/ftplugin/man.vim\" 定义:Man命令查看各类man信息的快捷键nmap &lt;Leader&gt;man :Man 3 &lt;cword&gt;&lt;CR&gt;\"let g:asyncrun_open = 4let g:asyncrun_bell = 1nnoremap &lt;S-W&gt; :call asyncrun#quickfix_toggle(4)&lt;CR&gt;nnoremap &lt;silent&gt; &lt;S-C&gt; :AsyncRun gcc -Wall -O2 \"$(VIM_FILEPATH)\" -o \"$(VIM_FILEDIR)/$(VIM_FILENOEXT)\" &lt;CR&gt;\" &lt;&lt;\" &gt;&gt;\" 工程文件浏览\" 使用 NERDTree 插件查看工程文件。设置快捷键，速记：file listnmap &lt;Leader&gt;fl :NERDTreeToggle&lt;CR&gt;\" 设置 NERDTree 子窗口宽度let NERDTreeWinSize=18\" 设置 NERDTree 子窗口位置let NERDTreeWinPos=\"right\"\" 显示隐藏文件let NERDTreeShowHidden=1\" NERDTree 子窗口中不显示冗余帮助信息let NERDTreeMinimalUI=1\" 删除文件时自动删除文件对应 bufferlet NERDTreeAutoDeleteBuffer=1\" &lt;&lt;\" &lt;&lt;\" &gt;&gt;\" 环境恢复\" 设置环境保存项set sessionoptions=\"blank,globals,localoptions,tabpages,sesdir,folds,help,options,resize,winpos,winsize\"\" 保存 undo 历史。必须先行创建 .undo_history/set undodir=~/.undo_history/set undofile\" 保存快捷键\"map &lt;leader&gt;ss :mksession! my.vim&lt;cr&gt; :wviminfo! my.viminfo&lt;cr&gt;map &lt;leader&gt;ss :mksession! my.vim&lt;cr&gt;\" 恢复快捷键\"map &lt;leader&gt;rs :source my.vim&lt;cr&gt; :rviminfo my.viminfo&lt;cr&gt;map &lt;leader&gt;rs :source my.vim&lt;cr&gt;\" &lt;&lt; \" 设置快捷键实现一键编译及运行nmap &lt;Leader&gt;m :wa&lt;CR&gt; :cd build/&lt;CR&gt; :!rm -rf main&lt;CR&gt; :!cmake CMakeLists.txt&lt;CR&gt;:make&lt;CR&gt;&lt;CR&gt; :cw&lt;CR&gt; :cd ..&lt;CR&gt;nmap &lt;Leader&gt;g :wa&lt;CR&gt;:cd build/&lt;CR&gt;:!rm -rf main&lt;CR&gt;:!cmake CMakeLists.txt&lt;CR&gt;:make&lt;CR&gt;&lt;CR&gt;:cw&lt;CR&gt;:cd ..&lt;CR&gt;:!build/main&lt;CR&gt;\" &gt;&gt;\" 快速选中结对符内的文本 \" 快捷键map &lt;SPACE&gt; &lt;Plug&gt;(wildfire-fuel)vmap &lt;S-SPACE&gt; &lt;Plug&gt;(wildfire-water)\" 适用于哪些结对符let g:wildfire_objects = [\"i'\", 'i\"', \"i)\", \"i]\", \"i&#125;\", \"i&gt;\", \"ip\"]\" &lt;&lt;\" 调用 gundo 树nnoremap &lt;Leader&gt;ud :GundoToggle&lt;CR&gt;\"======================F5 run script ================autocmd BufNewFile,BufRead *.py nnoremap &lt;S-R&gt; :w&lt;CR&gt; :!python % &lt;CR&gt;autocmd BufNewFile,BufRead *.pl nnoremap &lt;S-R&gt; :w&lt;CR&gt; :!perl % &lt;CR&gt;autocmd BufNewFile,BufRead *.scm nnoremap &lt;S-R&gt; :w&lt;CR&gt; :!racket % &lt;CR&gt; 同时，我们也配置一下tmux软件，tmux的配置文件是在～/.tmux.conf，如果没有该文件需要手动创建一个。 1234567891011121314151617181920212223set -g default-terminal \"xterm-256color\"#set -g prefix2 C-a#bind C-a send-prefix -2set -g display-time 3000set -g escape-time 0set -g history-limit 65535set -g base-index 1set -g pane-base-index 1set -g status-interval 1set -g status-keys visetw -g automatic-rename offsetw -g clock-mode-colour colour223setw -g mode-attr boldsetw -g mode-fg colour223setw -g mode-bg colour235set -g pane-border-bg colour234set -g pane-border-fg colour234set -g pane-active-border-bg colour232set -g pane-active-border-fg colour232set -g status-justify centreset -g status-bg colour235set -g status-fg colour248set -g status-attr dim 打造成的最终的VIM IDE效果如下图所示，VIM可配置性很强，基本上能满足日常的开发了。 ​ 本文省略了如何制作archlinux.img镜像文件的步骤，后面我将该镜像文件放入到百度网盘中，方便大家下载。总的来说，我们将闲置的安卓手机进行简单的DIY和调教之后，就可以当做普通的PC机来使用了。本文中最关键是讲述了这一系列操作流程的原理是啥，这样也有助于理解操作系统启动的原理。","categories":[],"tags":[{"name":"编程实践","slug":"编程实践","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]},{"title":"深圳西丽科目二考试细节","slug":"cartest2","date":"2018-09-10T13:37:18.000Z","updated":"2020-01-28T14:52:28.705Z","comments":true,"path":"2018/09/10/cartest2/","link":"","permalink":"http://sunjunior.cn/2018/09/10/cartest2/","excerpt":"","text":"科目二考试技巧要点考前准备 先进入踩离合，刹车，找到最佳离合点位置。 调整座位，先将座位调至最前面，然后背靠一下座椅后背卡紧，然后座位向后移动一格就可以了（本人只需要调整一格）。调整背靠，直到双手手腕能搭在方向盘上为止，左脚踩离合到底之后，腿弯曲程度与车面呈120度左右的方向。 调整后左右后视镜，左边后视镜的前车门把手预留5cm，后面把手只看到前下方，观察后视镜时能看到左边黄边线与车体平行（前宽后窄时 \\ |）。右边后视镜也是一样的调整方法，能看到车屁股。 系安全带 先来回试下车，找到离合半联动的最佳位置，相当于和考试车有个简单的磨合。 确认好自己的状态之后再按指纹确认考试，语音提示会报开始考试。 倒车入库 首先右倒库 右边门窗门灯突起点与黄线中重合停车。 右边打方向盘一圈零90度，车头回正之后停车，踩刹车，防止溜车。起步的时候，松一点离合，防止溜车。 左边天线与左边黄实线内侧一直重合。慢慢走到右侧库角和右侧把手最前面在一条线上停车。后面模拟训练中只要停车就一定要踩住刹车，防止溜车，血的教训啊。 停车起步先松点离合在放开刹车 往前走30cm左右，左车轮压到黄实线之后，右打方向盘一圈零90度，再往前走到前轮过控制线。切记倒车入库挂倒档之前一定要过控制线啊 挂倒档，右边后视镜底部与右库角30cm左右不用修正方向，其他情况哪边宽方向盘往对应方向打，哪边窄方向盘往对面打半圈。 右边倒库之后，然后进行左边入库，当左边门窗门灯突起点与黄线重合，向左打一圈零90度，直到前轮压过控制线。 挂倒档，左边后视镜底边向上三分之一地方要有2个脚宽，底部一个脚宽。哪边宽向哪边打，修正方向。 左边入库停车之后，出库时车头与黄线重合右边打死方向盘出控制线进入侧方位停车项 侧方位停车 左边天线与左边黄色实线内侧重合，走到前面黄实线与车头重合地方停车，然后在往前走30cm左右停车。 方向盘向右边打一圈零90度，挂倒档倒车，头伸出车外，观察左边库角。看到车尾与内侧库角成一条线时回正方向盘，继续观察左侧后车轮压过黄实线时将方向盘向左打死，观察车头盖左边缝隙与左边黄线内侧重合时停车。 打左转向灯，挂一档，左大灯与前面黄线重合时回正方向盘，考试的试与黄线重合时向右打一圈方向盘。 车头与前面线路平行之后回正方向盘。 遇到右转弯的时候向右打方向盘一圈零90度，直到车头回正到曲线入口时，回正方向盘。 这里可以在白色实线内停车休息一下。 曲线行驶 前面左大灯与前面黄线重合时，向左打一圈方向，车头左边线与黄线差不多重合时，再向左加90度。 左边大灯与右边曲线突起处重合时，回90度。车头左边线与左边黄线相差30cm时回正方向盘。 查看考试车的考字与黄色线重合时，向右打一圈，车头右边线与黄线重合时，向右再打90度。 左边大灯与曲线出口前方的黄色实线重合时，回正方向盘。然后右边大灯与黄线重合时，向右打一圈方向盘。直到车头回正之后，停车（踩刹车），回正方向盘。 直角转弯 打右转向灯，慢慢向前行驶，直到右边车门把手中间往后过去一点时，向右打死方向盘。 稍微松一点离合，然后车头回正之后回正方向盘。驶入白色线内停车。 半坡起步 白色线内让考试车的考字下边与白色线内侧重合，一直到半坡底部的起点地方，半坡底部起点的地方稍微松一点离合，防止溜车。 进入坡道之后，查看考试车的言字旁下边部分与黄线内侧重合，慢慢往前行驶。一直调整言字旁，保持与内侧黄线重合。到差不多看到停字车杆的时候，右脚放在刹车上。 观察左边后视镜下面，当左后视镜下边过第一根黄线之后，再观察第二根黄线，第二根黄线上部与左边后视镜有一个指头缝隙，停车。这里可以同时踩离合和刹车。 拉手刹，放手刹，方向盘向左打90度。离合慢慢放入半离合状态，车子震荡比较厉害时，放开刹车，车子往前走一点，回正方向。考试结束。 考试项目 注意要点 倒车入库 前车轮过控制线 侧方位停车 打左转向灯 曲线行驶 中途不能停车 直角转弯 打右转向灯 半坡起步 拉放手刹","categories":[],"tags":[{"name":"驾考经验","slug":"驾考经验","permalink":"http://sunjunior.cn/tags/%E9%A9%BE%E8%80%83%E7%BB%8F%E9%AA%8C/"}]},{"title":"程序员必读技术书籍推荐","slug":"Books","date":"2018-07-22T01:02:24.000Z","updated":"2020-05-04T00:41:12.042Z","comments":true,"path":"2018/07/22/Books/","link":"","permalink":"http://sunjunior.cn/2018/07/22/Books/","excerpt":"","text":"毕业6年来，我一直在回顾这几年的职业发展之路到底经历了什么，收获了什么。比如如何从应届小白完成到职场的转变；再比如身为程序员（软件方向的）究竟要阅读多少书才能称为高手。这里的书籍包括了技术的和非技术的。技术类的书籍属于程序员的职业基础。而非技术类的书籍属于程序员的软技能，可以有助于我们在职业生涯中迈入更高的台阶。那么哪些是程序员的必读经典书籍呢，这里根据我个人的经验来看可以是自顶向下，逐步深入到底层；也可以是自底向上，逐渐从底层原理到上层应用软件。计算机体系是一个分层次的庞大的系统，大体上可以分为三层，每个层次都有不少需要我们掌握的知识点，最底下的是硬件和汇编（对于软件来说主要是CPU和内存），是所有程序的编程基石。这部分对于程序员来说只需要了解硬件是如何称为软件的编程基础的，也就是说硬件中提供了哪些最基础的器件来支撑软件的运行。硬件上面就是操作系统层，操作系统就像是一个魔术师，将晦涩难懂的硬件接口抽象成了容易理解的系统API，程序员不需要关系硬件是如何在内部通信的，只需要指定该系统API能够达到什么目的。操作系统是软硬件的接口层，我们运行的软件基本都需要得到操作系统的控制。操作系统对软件提供服务, 对硬件抽象后，以更友好的接口来方便程序员门编写各类系统应用程序。最上层就是各类应用程序了（其中也包括了系统应用，比如编译器，解释器，shell等等），比如我们常见的各类PC客户端，服务端软件都属于这一层次。下面以我的个人经历，逐步地推荐一些经典好书，帮助小白在IT生涯前期少走一些弯路，也是对我自己读过的一些经典书籍的总结和回顾。下面从我的大学求学之路开始说起： 我本科学习的信息与计算科学，这实际上是数学的一个现代分支，除了学习传统的微积分和高等代数之外，我们的专业课程里面还涉及到了各种离散化的算法计算，比如现代密码学就涉及到了初等数论，这里面就研究整数的一些特性。再比如有一门课叫做数值分析，主要利用一些近似算法来无限逼近真实值。在开设这些课程期间，其中大多数算法实验都是在SAS,MATLAB上完成的，当时自己对计算机的认识很模糊，因为我们课程关注的是算法本身，而不少计算机语言和计算机相关的工作原理是没有深入理解的。这些课程恰好是CS专业要掌握的知识。 大二开设C语言课程之后，对于C语言的指针，内存管理那一部分有些痛苦，工作之后才发现，C语言不完全是一门高级语言，更是一门系统级的编程语言，需要和操作系统一起来掌握学习，这样才能更深入理解。比如指针的本质是啥，指针类型呢，各类指针操作又是怎么回事，函数指针，二级指针用于哪些场景等等。这些没有一些项目经验和系统的了解，是无法得到准确答案的。后面毕业之后有幸地读取了数据挖掘方向的研究生，研究生期间了解了各类现代优化算法，各类分类聚类算法，个性化推荐算法等等。有部分甚至来自其他领域，比如生物学仿真算法（从其他低等生物研究抽象出来的算法模型），这里经典的就有神经网络，进化算法（遗传算法），蚁群算法，模拟退火等等。这些算法本身比较奇妙，在某些领域也达到了比较理想的应用。比如神经网络在分类预测方面就有显著的应用，曾经参加数学建模，我们团队打算就是利用了神经网络来预测中国人口等等。不过这些算法的实现由于在MATLAB里面有现成的工具箱可用，我们只需要对选择函数，参数等进行训练调优即可。也就是说研究生期间个人对计算机这部分知识原理几乎为0，更多地是研究一些这些算法本身如何优化，有哪些应用场景等等。 到研究生毕业那一年，这一年才成为我人生的转折点，临近研三的时候，上半年由于个人时间比较多，而毕业生论文也刚刚起步，我每天都在图书馆泡着，开始为找工作做一些前期准备，毕业之后也打算从事IT相关的岗位（当时由于数据挖掘（大数据）没有现在这么火，大都还是传统的C/S和B/S架构的应用开发工程师）。在图书馆，我有幸读到了一些非常经典的书籍。在图书馆学习了大半年，我读了IT书籍数十本，但是我认为非常经典的就是那么几本，这些书能宏观系统地教你一些计算机系统方面的理论原理，为后续职业发展起到了良好的铺垫作用，第一本书就是《编码，隐匿在计算机软硬件背后的语言》，这本书属于科普图书，一拿到手中，看起来是那么的清晰易懂。后面得知原版是微软的某个大牛写的，将计算机原理复杂的逻辑，利用一些导线，开关来逐步深入介绍，对计算机运行机理有着比较详细的解说。这对于我这种非计算机，不懂电子硬件的小白来说着实有着不小的吸引力。 另外一本书就是《Linux C编程一站式学习》，当时该书还没有纸质的，我阅读的是电子书，该书以C作为切入点，系统讲解了C语言，C语言如何编译运行在操作系统下，程序的运行原理等等基础知识。这本书我觉得是少数国人在计算机领域写得最好书籍之一。书介绍的内容都不多，但是比较有系统性，作为一个没有经过系统训练的程序员，阅读此书之后有一种醍醐灌顶的感觉，把多年来自己离散的计算机基础知识拼接到了一起。这书有纸质版上市了，不过我还是觉得电子版的更完整一些。 研究生期间还阅读过基本经典原理图书，我印象中有3本，一本是《深入理解计算机系统》，另外一本是《程序员的自我修养，链接、装载与库》，还有一本就是《现代操作系统》。这3本书当时也是看了图书馆的样本书之后，在网络上买的纸质书。《深入理解计算机系统》简称CSAPP，这本书被列为程序员的圣经，该书就是对《Linux C编程一站式学习》一书的补充和完善，我买的时候是修订版本，现在最新版本是第三版，以X86-64架构作为基础讲解。 研究生毕业之时，趁着京东618搞活动，IT技术书籍满减活动，买了几本书籍，由于之前看了不少类似这类经典书籍，因此阅读后面技术书籍也有比较好的底子了。后面工作后的几年，也买过不少经典好书。下面列出的是我后面买的经典书籍，非常推荐大家看一看，其中有不少属于国内IT技术精品图书。 《计算机系统要素》对于应用软件人员来说，计算机硬件其实了解的不用太深入，而嵌入式软件开发工程师，底层软件，bsp等驱动开发工程师等需要对硬件接口文档，硬件各种外围芯片的特性功能等要了解一些。因此对于大都从事应用开发的人员来说，了解一下计算机的运行机理就可以了，这里另外一本我特别喜欢的书籍《计算机系统要素》，可以阅读前面几个章节。这2本书主要系统地如何从零开始，利用布尔逻辑来实现各类逻辑门电路，实现一个简单的CPU等等。对这些元器件理解是决定我们软件领域的路走得更远。如果想了解了硬件的工作原理，CPU是如何工作的等等，这本书会对我们编写的程序有着引导作用。 《计算机程序构造和解释》该书是MIT教学的一本经典教材，书中用scheme来讲解了如何组织抽象的数据和程序，全书都是围绕这抽象这一概念进行展开，讲解了lambda演算，函数式编程，闭包，Y算子等概念模型，使我们更加清楚的计算的本质是什么。不过该书不适合小白阅读，适合有一定的编程基础的人阅读，阅读之后绝对对个人的编程思想，编程方式产生较为深刻的影响。本书一直在强调处理数据的抽象原则，数据和过程是对立又统一的矛盾体，二者在某些场景下可以相互转换，过程即数据，数据即过程。 《Effective系列丛书》由于毕业之后一直从事嵌入式软件开发，用的最多的还是C/C++语言,这里看完了C/C++的基础语法之后，如何写出更好的C++程序来，这里有一系列C++的书籍，其中最有影响力的Effective系列图书三部曲。这里三部曲指的就是《Effective C++》、《More Effective C++》、《Effective STL》这三本书。这些书籍能指导我们在平时编码中，有意识地会约束自己的编码习惯，使其符合其中的一条或者某条，写出的程序扩展性更强，便于后期维护，当然本书不能代替编码本身带来的经验。在项目中经历了多个特性开发之后，再回过头来看本书的一些条款，发现提早做这些工作能尽量少踩坑。 《C++反汇编与逆向分析技术揭秘》本书深刻揭示C++内部工作机制，透过汇编语言来看隐藏在语言内部的动作，也就是通过这一层关系，我们能深刻认识到C++语言一些语法特性的原理，和C语言有哪些差异等等。语言本书为我们做了哪些东西，我们用C++开发程序时，这部分代码映射到底层是怎么样的，了解这部分背后的动作之后，能为我们编写高质量的C++代码打下良好的基础。虽然我们平时很少逆向分析，逆向分析一般用于病毒分析，破解等领域，但是逆向分析能为对语言本质性的东西有着深层次的认识。 《UNIX环境高级编程》本书也被誉为UNIX/LINUX系统编程的圣经，当我们了解操作系统提供的各类服务之后，如何利用这些接口来编写程序呢？本书就详细介绍了类UNIX系统常用的接口使用方法，书中也给了非常经典的实例。学习此书之后，基本上对类UINX系统上编程有了初步的认识。本书由UNIX技术牛人W.Richard Stevens所作，他生前著有多种经典的传世之作，比如《UNIX网络编程》（两卷本）、《TCP/IP详解》等等。 《深度探索C++对象模型》本书详细描述了C++的底层实现细节，如果我们之前学习过C语言，了解C语言的内存布局，那么读这类书籍就是如虎添翼。书中讲解了大量C++的语言特性实现细节，比如C++虚函数实现机理，RTTI运行时类型识别等等，了解C++底层实现细节之后，我们在利用C++语言的时候就能做到有效取舍，在效率和可读性方面达到平衡。 《重构,改善既有代码的设计》重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。本书虽然为java讲解的，但是并不影响其他语言的使用，书中有大量的实例，重构之前和重构之后代码结构好在哪些地方，书中都有区分比较，该书也是计算机领域的一位大牛编写的，值得大家反复阅读。 《正则表达式系列丛书》正则表达式是每个开发人员必须掌握的知识之一，尤其是在处理文本处理方面。随着互联网的迅速发展，几乎所有工具软件和程序语言都支持的正则表达式也变得越来越强大和易于使用。C++11以上版本开始支持正则表达式，而大部分脚本语言天然支持正则表达式，比如perl语言本身就支持，而python,java等也有对应的库支持。下面有2本书都讲得不错，一本是《精通正则表达式》，另外一本是《正则指引》，两本书都是技术专家余晟翻译或撰写的，写的比较详细，通俗易懂。其中《精通正则表达式》是一本经典之作。本书主要讲解了正则表达式的特性和流派、匹配原理、优化原则、实用诀窍以及调校措施，并详细介绍了正则表达式在Perl、Java、.NET、PHP中的用法。而《正则指引》一书更多地是作者结合实际的项目经验开发遇到的问题，以及其他开发人员咨询的问题，总结出一套使用正则表达式解题的办法，并通过具体的例子指导读者拆解、分析问题。《精通正则表达式》偏重理论，《正则指引》则重视实践。 《UNIX shell范例精解》本书就是常用的一些shell命令的宝典库，可以平时作为开发的案头书籍，书中详细介绍了awk、sed及grep等内容，以及不同的shell语言的写法，平时shell脚本可以参考此书。 《Head First 设计模式》这本书是我学习设计模式中第一本书籍，其他的还看过《设计模式之禅》。书利用自问自答的方法讲解了软件常用的设计模式，这类模式在什么场景下使用，用于解决什么问题，说的简单一点就是，设计模式就是软件在项目实践中的最佳用例（最佳实践）。作为一门软件开发者，掌握常用的软件开发模式能让我们在编码时做到代码的可扩展，可维护，符合SOLID原则。 《汇编语言》王爽的经典书籍，这里就不用多说了，基本适合零基础学习的人员看。 其实还有许多经典书籍，这里也不一一介绍了，比如《代码整洁之道》、《编程珠玑》、《计算理论导引》等等，都是很好的书籍。看过上面的图书之后，起码对计算机理论有了个基本认识。后面还需要自己在各自的领域精耕细作才会有更好地发展体会。专业领域的书籍太多，这里也不作过多说明。这几年人工智能，区块链等等又开始火了起来，但是底层技术这一块这几十年没有质的变化。阅读好这些经典书籍之后，再看市面上有的各类“新技术”书籍也能做到游刃有余。技术书籍的内容也遵循二八法则，只有那20%的东西可能对你是有用的，其他大部分知识都是前人的已有成果或者说你已经掌握好了。以上就是我这几年看到的，认为比较经典的，值得大家一看的书籍，一致推荐给大家。","categories":[],"tags":[{"name":"编程人生","slug":"编程人生","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"}]},{"title":"函数式编程的几点思考","slug":"Function","date":"2018-05-17T08:31:05.000Z","updated":"2020-05-04T00:31:33.374Z","comments":true,"path":"2018/05/17/Function/","link":"","permalink":"http://sunjunior.cn/2018/05/17/Function/","excerpt":"","text":"函数式编程的几点思考关于抽象 我们已经知道，过程就是一类抽象，它们描述了对于数的复合操作,比如，在定义： 1(define (cube x) (* x x x) 我们讨论的并不是某个特定数值的立方，而是对任意的数得到其立方的方法，当然，我们也完全可以不去定义这一过程，而是列出详细的表达步骤： 12(* x x x)(* y y y ) 这里如果不把cube抽象出来，当存在大量的复杂运算时，我们就会把自己给绕晕了，理论上，把所有计算过程详细地列出来，也能很好的工作，但不能表述立方这一概念。我们对这些公共模块建立抽象之后，就可以直接在更高层次上工作。实际上，所有高级语言提供的的函数机制，其就提供了这种能力。如果只将过程（函数）作为输入参数，那么会限制我们建立抽象的能力。实际上，作为高级抽象语言，我们可以将任何数据都作为过程来看待，也就是说，过程的输出可以当做另外一个过程的输入，同时也可以将过程本身作为过程的参数，或者以过程作为返回值，这类能操作过程的过程称为高阶过程。 过程(函数)作为参数下面用Lisp语言描述其步骤，最后给出如何用C语言书写等价代码，C语言需要通过回调机制来抽象求和步骤。 考虑下面三个过程，第一个计算从a到b的各个整数之和：1234(define (sum-integers a b) (if (&gt; a b) 0 (+ a (sum-integers (+ a 1) b)))) 第二个计算给定范围内的整数的立方之和：1234(define (sum-cubes a b) (if (&gt; a b) 0 (+ (cube a) (sum-cubes (+ a 1) b)))) 第三个计算下面的序列之和： \\frac {1} {1 \\cdot 3} +\\frac {1} {5 \\cdot 7} + \\frac {1} {9 \\cdot 11} +\\cdots它将收敛于:\\frac {\\pi} {8} 1234(define (pi-sum a b) (if (&gt; a b) 0 (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b)))) 可以看出，这三个过程共享一种公共的模式。它们很大一部分是共同的，只在所用的过程名字上不一样：用于从a算出需要加的项的函数。我们可以通过填充下面模板中的各空位，产生出上面的各个过程： (define (&lt;name> a b) (if (> a b) 0 (+ (&lt;term> a) (&lt;name> (&lt;next> a) b)))) 数学家很早就认识到序列求和中的抽象模式，并提出了专门的“求和记法”，例如： \\sum_{n=a}^{b}f(n) = f(a) + \\cdots + f(b)","categories":[],"tags":[{"name":"编程思想","slug":"编程思想","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"汇编语言学习总结","slug":"assembly","date":"2018-03-17T08:31:05.000Z","updated":"2020-05-04T00:39:07.746Z","comments":true,"path":"2018/03/17/assembly/","link":"","permalink":"http://sunjunior.cn/2018/03/17/assembly/","excerpt":"","text":"概述 从事嵌入式工作领域有几个年头了，平时大都时候都与硬件或者计算机系统本身相关，编程也是基于硬件资源编程。通过这几年的学习总结，对计算机系统内部运行机理也掌握了不少要领，然而总感觉自己少了点什么。这里少的东西指的就是缺少了对硬件的理解和掌控。我们知道，现在的计算机都会安装操作系统，对于PC机来说，操作系统相当于计算机硬件的管家，将所有硬件资源在操作系统这一层次进行了屏蔽。现代计算机操作系统基本都是在保护模式下运行，通过硬件MMU和操作系统相互配合来达到这一目的，最终实现多任务操作。简单点说，我们编写的大部分程序不能直接对硬件进行访问，只能利用操作系统提供的应用程序接口（API）来实现各类应用软件的功能。经过了操作系统这一层抽象，很多硬件细节上的功能，我们就无法知晓了。比如驱动程序是咋回事，键盘打字是怎么回显到显示器上的，能不能自己写个程序，绕过操作系统来实现程序的加载运行等等。之前自己也搞过51单片机的东西，实际上51单片机也可以称为小型的计算机系统，编写51单片机系统运行就是一个简单的main函数，没有任何操作系统。因此个人需要进一步加深对系统的理解，就需要掌握计算机的整个启动流程是怎么样的。CPU上电之后，实际上当前是处于实模式下的，上电之后最先启动的是BIOS系统，会对计算机硬件进行自检，比如CPU，内存，硬盘等等资源检测，看看是否处于正常工作状态。BIOS系统就是直接对系统进行管理。里面有不少代码是汇编语言编写的，要了解实模式下软件程序的编程，就需要知道汇编语言是如何编写的。同时熟悉汇编语言（不一定非得要写出来，懂得运行原理就可以了）也可以能很好的帮我们理解C语言的工作模式，看看编译器帮助我们做了什么东西。对于计算机程序的理解是非常有益的。总的来说，学习汇编语言对我职业发展有如下几点好处： 对深入理解计算机底层运行原理，学习计算机操作系统等有实质性的帮助。 对编程语言学习提升也有较大帮助，能加深理解C与汇编之间的对应关系（也就是高级语言和机器语言之间的对应关系）。 学习计算机系统安全，软硬件加密解密，逆向破解，计算机病毒等分析有不少帮助。 汇编语言教材选择 市面上有不少汇编程序语言程序设计的教材，而对于我这种对硬件不是特别懂的人来说（没有学习过微机原理和接口，数字和模拟电路等等）,选择一本合适的教材来自学是比较难找的。不过值得庆幸的是，国内有不少教材深入浅出，讲解的浅显易懂，有层次，有逻辑。大家公认的就是王爽老师的出版的《汇编语言》一书，目前该书已经到了第三版,该书在豆瓣评分都有9.1分，国内书籍中有如此高分的计算机图书还是比较少见的。因此我也选择这本书作为入门教材，在国内购物节的时候以5折的价格购买了回来。此外汇编程序设计还有win32汇编程序设计等等图书，市面反响也不错。不过作为入门教材，最好是以简单的内容为模板，该书以8086CPU为讲述对象，讲解了CPU工作原理，书中很多地方都体现出了一种哲理性的东西，浅显易懂，不愧为汇编语言教材中的经典！ 汇编语言学习心得 经过为期3周左右的学习，我基本上已经掌握了8086 CPU汇编语言程序设计的常见技巧，对计算机程序的运行原理又有了新的认识。下面谈谈我对汇编程序语言的理解吧。这里不涉及到汇编具体用法，只涉及到我对汇编语言和CPU运行程序原理的认识。汇编语言是一门面向机器的语言，简单点说和机器码是一一对应的。当然严格说来汇编语言包含了伪指令和汇编指令。其中伪指令为汇编器指示标记，不对应机器码，主要用于指示在汇编期间关联或者计算相对位移等等作用的代码。汇编指令经过编译之后就会对应上CPU可以运行的机器码。X86架构下的汇编语言与arm、架构下的汇编语言编写是有差异的，主要是在寄存器使用上的差异。不过学习了一种架构体系下的汇编语言，其他体系下的汇编学习也可以举一反三，触类旁通。 计算机汇编语言的学习要站在CPU的角度来看待问题。我们将内存，显卡，其他接口卡，外围芯片统一编址，统一规划，各种硬件模块都有属于自己的地址空间，对于CPU来说没有本质的区别，都是对指定地址上的内容进行读写。本质上，放入到内存中的数据是不区分什么是代码，什么是数据的，都是用二进制数来保存的。我们设计程序，将一段内存中的数据有时当做了代码来执行，有时当做了数据，还有时候模拟程序中出现的堆栈模型等等，这些都是根据实际需要来设定的。如果想要让CPU将一段数据作为代码段，可以将CS,IP指向该内存首地址即可；如果想要让其作为数据段，则只需要设置DS寄存器指向该内存的地址；看做堆栈，模拟数据的先进后出，就可以将SS寄存器指向该内存地址，SP指向当前栈顶位置。对于汇编程序设计来说，主要就是用好CPU指定的那十几个寄存器，了解每个寄存器主要作用。比如段寄存器有CS,DS,SS,ES等等，分别用于代码段，数据段，堆栈段，附加数据段等等。AX,BX,CX,DX是通用寄存器，一般可以互换使用。但是实际使用上还是有差异的，也可能是约定俗成的东西，比如AX一般用于累加，BX作为基址寄存器，CX作为计数寄存器，DX作为数据寄存器，用于I/O端口存放地址。一段内存数据，既可以作为代码段，又可以作为数据段，还可以作为堆栈段，关键是看实际解决问题的便利性。在编写中断处理程序的时候，我们编写的程序首先要作为数据拷贝到指定的地址上去，这个时候是作为数据来的。而触发中断时，我们编写的程序需要立即相应中断号，这时是作为代码来看待的。另外，学习汇编语言，书中讲解了与C语言的一些关系。比如汇编中的变址寻址方式，在C语言中就可能会对应数组，二维数组等等。汇编中将子例程的标号地址放入到一起，通过查表来取得对应的子程序执行，对应上的就是C语言的函数指针数组技巧，本质上就是表驱动法的实际应用。在比如C语言中的函数调用，涉及到PUSH和POP等入栈和出栈操作。这里本质上是为了保存现场，在调用子程序结束之后恢复到调用之前的状态。学习汇编对学习高级语言，甚至有时候为了定位用高级语言编写导致的一些莫名其妙的问题，汇编可能是救你的最后一根稻草。 下面是用汇编语言来写一个MBR(填写盘符最开始的512字节)，制作一个软盘，启动之后显示指定字符，从而绕过了操作系统： ; MBR显示实例 org 0x7C00 ; 指明程序装载地址 ; 初始化寄存器 mov ax, 0 mov ss, ax mov ds, ax mov es, ax mov sp, 0x7C00 ; 移动 Stack Pointer mov si, msg ; 标识 Source Index putloop: ; 循环显示字符 mov al, [si] ; 移动第一个字符到寄存器，即 &#39;h&#39; add si, 1 ; si++ cmp al, 0 ; 检查 null terminator je fin ; jump is equal mov ah, 0xe ; 显示一个文字 mov bx, 15 ; 指定字符颜色 int 0x10 ; 通过 0x10 中断显示一个字符 jmp putloop fin: ; 当需要显示的信息都显示完毕，那么进入死循环 hlt ; 让CPU停止，等待指令 jmp fin ; 死循环 msg: ; 设定需要显示的字符 db 0xa, 0xa ; 换行两次 db &quot;This is MBR Start!&quot; db 0xd ; Carriage Return db 0xa db 0 ; null terminator endpart: times 510-($-$$) db 0 ; 填写0x00直到0x001fe, 0x001FE == 510 db 0x55, 0xaa ; magic 上面的程序是用nasm汇编语言写的，将上面的程序保存为mbr.asm之后，可以用nasm编译生成目标文件:nasm mbr.asm -o mbr.bin然后制作成1.44M的软盘，前面的512字节是MBR引导程序，后面的空间用0来填充即可：dd if=/dev/zero of=mbr.bin bs=512 seek=1 count=2879最后用qemu来模拟软盘启动，打印指定的字符串：qemu-system-i386 -drive file=mbr.bin,if=floppy 总结 本文主要讲述了我这段时间内学习汇编语言的所思所得。在学习完成8086汇编语言知识之后，自己可以继续学习win32的汇编程序设计，体会该模式下与DOS实模式下编写汇编有什么明显差异等等。此外，自己还可以研究下nasm汇编语言，nasm汇编是一门比较主流的汇编，支持各类主流程序，比如win32,elf等等。这里有几个学习网址，后期可以进一步深入理解学习逆向工程，破解和解密软件打好基础！http://cs.lmu.edu/~ray/notes/nasmtutorial/http://www.nasm.us/xdoc/2.13.03/html/nasmdoci.htmlhttp://asmtutor.com/http://www.plantation-productions.com/Webster/http://asm.sourceforge.net/resources.html#docs","categories":[],"tags":[{"name":"编程实践","slug":"编程实践","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]},{"title":"利用qemu模拟器安装ppc操作系统","slug":"ppc","date":"2018-03-04T00:56:49.000Z","updated":"2020-05-04T00:43:58.912Z","comments":true,"path":"2018/03/04/ppc/","link":"","permalink":"http://sunjunior.cn/2018/03/04/ppc/","excerpt":"","text":"背景介绍由于从事嵌入式工作领域的缘故，本人需要研究下程序在不同CPU类型下的行为模式是否与预期一致。目前市场上大都CPU按照大小端架构体系来划分的话，大部分都属于小端字节序类型，大端CPU在市面上很少见。比如小端字节序的有arm（A9,A15），x86系列。大端则主要是基于PowerPC架构的，比如摩托罗拉68000型中央处理器，还有通讯领域采用的网络处理器，也有大端类型的。于是，个人需要找一款可以在PC电脑上模拟不同CPU类型的模拟器，来运行不同CPU架构的操作系统，验证程序在不同CPU类型下行为模式。如今，随着虚拟化技术进一步发展，市场上有许多可用的虚拟化工具来帮助我们来运行各类不同的操作系统，比如强大的VMware虚拟机，我本人之前用过破解版的VMware，该虚拟机确实对各类硬件模拟都有比较好的支持，可惜是正版要收费的。当然市场上也有不少免费的虚拟机工具，免费的虚拟机工具主要有以下２款： １）Oracle VirtualBox维基百科上说最早VirtualBox是由德国InnoTek软件公司出品的虚拟机软件，现在则由甲骨文Oracle公司进行开发，是甲骨文公司xVM虚拟化平台技术的一部分。它提供用户在32位或64位的Windows、Solaris及Linux 操作系统上虚拟其它x86的操作系统。用户可以在VirtualBox上安装并且运行Solaris、Windows、DOS、Linux、OS/2 Warp、OpenBSD及FreeBSD等系统作为客户端操作系统。 2）QEMUQEMU是一套由Fabrice Bellard所编写的模拟处理器的自由软件。它与Bochs，PearPC近似，但其具有某些后两者所不具备的特性，如高速度及跨平台的特性。经由KVM（早期为kqemu加速器，现在kqemu已被KVM取代）这个开源的加速器，QEMU能模拟至接近真实电脑的速度。QEMU有两种主要运作模式： User mode模拟模式，亦即是用户模式。QEMU能引导那些为不同中央处理器编译的Linux程序。而Wine及Dosemu是其主要目标。System mode模拟模式，亦即是系统模式。QEMU能模拟整个电脑系统，包括中央处理器及其他周边设备。它使得为系统源代码进行测试及除错工作变得容易。其亦能用来在一部主机上模拟数部不同虚拟电脑。 这2款虚拟化工具各有特点，virtualbox入手比较简单，安装之后可以安装部署步骤一步步傻瓜式安装，基本可以模拟市场上所有主流的操作系统。但是qemu自由度更大，而且适配的CPU类型更广，直白一点就是自由定制化程度较高，安卓模拟器内部用的就是qemu。这里我需要模拟大端cpu类型，典型的大端CPU架构就是powerpc。用qemu模拟ppc模拟器很简单，qemu安装之后就会有模拟ppc的命令提供使用。经过比较发现，这里选择用qemu来模拟比较合适。下面就开始介绍如何用qemu来模拟ppc，并且运行ppc操作系统的过程。 操作系统选择操作系统的话，大端字节序的目前比较稳定的版本有Ubuntu和debian系列。我这里采用Ubuntu发布版本，由于只是模拟CPU，使用的操作系统可以选择轻量级别的，比如lubuntu，于是首先下载lubuntu for ppc最新版本的，下载地址为lubuntu下载地址。我们选择对硬件性能要求不高的alternate版本: 制作qemu镜像下载操作系统之后，我们首先需要创建一个qemu文件系统镜像，大小为10G左右qemu-img create -f qcow2 ppc.img 10G 创建完成之后，就可以将iso操作系统镜像当做cdrom来完成操作系统安装了，这里我们只需要设置内存大小为1G,硬盘模拟hda,安装操作系统的命令如下:qemu-system-ppc -m 1024 -hda ppc.img -cdrom lubuntu-12.04-alternate-powerpc.iso -boot d如下图所示，系统会弹出qemu启动界面，在里面输入install就可以启动Ubuntu系统安装程序了这里安装时间花了约1小时，如果自己的PC机器性能较高，可以在模拟计算机硬件的时候，将分配的资源多一点，比如内存可以设置2G,CPU可以设置多个核等等。 配置linux开发环境在系统安装完成之后，由于qemu不会安装bootloader，所以需要手动指定磁盘根目录和系统内核文件(这个需要在iso镜像中提取出来)。我们重新用qemu-system-ppc来启动ppc.img镜像看看:qemu-system-ppc -m 1024 -hda disk.img -kernel vmlinux -initrd initrd.img -append &quot;ro root=/dev/sda3&quot;这里由于需要用guestfish工具来提取镜像，这个工具在redhat比较好用，这个工作暂时告一段落,懒得折腾了。如果个人使用是Redhat红帽系列的操作系统（Centos，Fedora等等），可以按照上面的步骤制作安装镜像。由于网上直接可以下载debian for ppc的qemu镜像文件，于是我下载了一个debian系列的qcow2文件(debian_wheezy_powerpc_standard.qcow2)，下载完成之后就可以用qemu运行了:qemu-system-ppc -hda debian_wheezy_powerpc_standard.qcow2 进入到操作系统Shell控制终端，打开vi修改域名和软件源，否则可能无法更新工具链。vi /etc/resolv.conf修改域名为国内的114.114.114.114,比较稳定。另外软件源用网易163或者其他国内镜像源都不好用，主要是没有powerpc 32bit的源.这里我找到一个可以使用的源：debian powerpc源vi /etc/apt/sources.list 修改完成之后，更新下源，然后安装linux C开发工具链，写一个简单的程序来验证下ppc系统下CPU访问和存储字节序的过程。apt-get install vim gcc g++可以看出，字节序跟预期一致，低地址存放的是高字节，高地址存放的是低字节。这个跟小端CPU存放顺序是相反的。 总结 qemu模拟器是一款非常强大的工具，可以模拟各种类型的CPU和硬件类型,在后面的学习过程中，如果学习操作系统，系统编程等等方面的知识，可以用模拟器上做测试验证，方便得很。","categories":[],"tags":[{"name":"编程实践","slug":"编程实践","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]},{"title":"《计算机系统要素》读书笔记","slug":"ElementsOfComputer","date":"2018-02-10T13:22:55.000Z","updated":"2020-05-04T00:41:39.436Z","comments":true,"path":"2018/02/10/ElementsOfComputer/","link":"","permalink":"http://sunjunior.cn/2018/02/10/ElementsOfComputer/","excerpt":"","text":"概述作为一名软件开发人员，硬件知识的学习也是必不可少的一部分。只有理解了计算机硬件的基本组成，工作原理才能更好地优化程序。作为非计算机专业的开发人员来说，有２本书值得大家阅读，一本是《编码，隐匿在计算机软硬件背后的语言》，另外一本书则是本文要解读的《计算机系统要素》一书。两本书都是讲述了计算机底层的实现原理，侧重点有所不同。前者主要侧重理论，虽然书中讲的例子是利用了一些继电器开关，导线来组合基本逻辑门电路，比如与门，或门，非门等等，而后再基于逻辑门电路来完成基本的电路元件，比如Ｄ型触发器，锁存器，ALU，计数器，ＲＡＭ阵列等等。但是对于我们真正意义上理解也是停留在理论阶段。我们不可能真去市场上买些继电器开关来完成书中所给的例子。本文要讲解的《计算机系统要素》也是讲解的这类知识，只是说书中有配套的小项目给我们来完成，从布尔代数，布尔逻辑来完成数字电路中组合逻辑和时序逻辑门电路。本书中给了一个模拟仿真器，虚拟机和一个可运行的操作系统，可以用HDL语言来完成逻辑功能。总的来说，这本书实战性较强，看完这两本书之后再去看计算机硬件的接口设计和汇编语言应该更容易理解。汇编语言写的通俗易懂的就是王爽编写的那边《汇编语言第三版》，推荐大家阅读。本文连续载录《计算机系统要素》每一章讲述的内容重点。 第一章 布尔逻辑 布尔逻辑简单点说就是真假逻辑，同一事物只能要么是真，要么是假，用数值来说就是只能是0或者1，用函数来表示为二值函数，比如现实中灯泡的亮与灭，开关的通断。基本的逻辑门包括非门（也称为反相器），或门和与门。由这三种最基础的门电路构成了计算机系统的基石。刘慈欣的《三体》中描述了的就是这类现象，通过简单的门电路来构造强大的计算机系统：冯诺依曼向秦始皇展现如何构造一台计算机系统。冯诺依曼则向秦始皇要三千万兵，每几个兵组成了非门，或门，与门，与非门等等，通过简单的逻辑门，然后再基于成千上万的逻辑门通过一定的秩序（这里需要时序逻辑）来完成复杂的芯片实现。书中介绍了基本的门逻辑其实是与非门或者是或非门，由这两种基本的门电路能实现所有的其他逻辑门，第一章项目中要我们实现的就是这一类问题。其实大家都很好奇，如何通过这简单的门电路来实现复杂的芯片呢，比如CPU中的ALU，寄存器，计算机内存等等，后面的章节应该会陆续介绍其实现机理。 第二章 布尔代数 本章的核心其实就是设计计算机CPU最核心的部件ALU，算术逻辑单元，我们知道计算机由CPU两大部分组成，主要包括了运算器，控制器（还包括其他的状态寄存器）。这里的运算器就是指的ALU，是计算机的核心部件。这里利用第一章所讲的东西，实现了半加器，全加器和16位加法器。其实本书可以和微软出版的《编码：隐匿在计算机软硬件背后的语言》一书相互借鉴。基本讲的都是一类东西，如何构造出一台计算机。文章第一部分就介绍了下背景知识，数的进制，一般人类喜欢用十进制，考虑到手指有10根，但是对于计算机来说，二进制比十进制要方便很多，其原因还是因为有布尔逻辑作为理论支撑，其次是为了计算机的实现，本质上逻辑门就是一个开关，开关对应于人的思维模式就是二元真假逻辑，映射（同构）到物理形态上可以用电流的有无，电压的高低，开关的通断，灯泡的亮灭等等来表达。接着要我们来实现一个半加器和全加器，半加器是全加器的基础，其实就是需不需要考虑进位作为输入而已。我们在十进制加法中也会考虑进位作为输出，全加器实现了两个bit相加得到的结果，实现16位加法器可以利用多个全加器来组合完成。最后就是综合所有的逻辑状态来实现ALU，输入中多了几个控制状态位来控制输出结果。其实计算机加法是基础，后面的减法，乘法和除法都可以基于加法来搞。当然由于提高效率，现代计算机有专门的乘法器来提供计算了。了解本章之后，对计算机的核心部件有了个基本认识。 第三章 时序逻辑 本章的核心讲解时序逻辑，这章讲解的跟之前的组合逻辑有着显著的区别，时序逻辑电路是一种反馈电路，之前讲解的组合电路是不具备记忆保存功能的，即不能保存自身的状态，当输入发送变化时，其结果受到当前输入的影响。而时序逻辑是一种带有记忆功能的电路，最简单的就是D型触发器（Data Flip Flop, DFF），可以用２个或非门逻辑来完成其功能，其中每个逻辑门的输出作为另外一个逻辑门的输入，使其电路具有反馈功能，这样的电路就会带有“记忆”功能，触发器能保存1bit信息，那多个触发器就可以保存多个bit信息。D型触发器跟组合逻辑Nand门一样，是计算机中最底层的时序逻辑门了，后面的n位锁存器，计算器，RAM阵列都是基于DFF门来构建的。实际上也是这样一个道理，任何复杂的逻辑，如果分解到最小单元的话，一定是最简单的二元逻辑了。总的来说，有了基础的时序逻辑电路－－触发器之后，我们就可以利用多个触发器来组合成Memory Ram阵列，计数器，ALU等等计算机重要的部件了。","categories":[],"tags":[{"name":"编程实践","slug":"编程实践","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]},{"title":"安卓手机安装Archlinux系统搭建web服务","slug":"Archlinuxarm","date":"2017-12-30T09:51:35.000Z","updated":"2020-05-04T00:36:41.693Z","comments":true,"path":"2017/12/30/Archlinuxarm/","link":"","permalink":"http://sunjunior.cn/2017/12/30/Archlinuxarm/","excerpt":"","text":"家里有2台闲置的安卓手机，长期摆放在家里，属于吃灰状态，目前我一直在找机会让其发挥余热。比如用此安卓手机来搭建个人博客，或者开启远程摄像头，监控家中的一切，手机长时间开着功耗也比较低，不费电。经过这几天的折腾，终于可以让其运行archlinux最新系统，后台运行个人博客web程序了。下面将这些流程用图文并茂的形势记录下来，以备后用。安卓手机内核运行的就是linux系统，因此理论上是可以安装其他发行版本的linux系统的，不过由于各个手机厂商的手机驱动不好获取，不然可以启动的时候就可以调到linux系统运行了（类似于PC机）。目前给安卓手机安装发行版linux系统基本都是基于chroot的，也就是说将发行版的linux镜像挂载在某个路径下，这里一般为/mnt，然后利用手机的资源分配给当前的linux挂载镜像，最后chroot到该系统下，即可以跑这个系统的版本了。由于我本人用archlinux，同时该系统有着良好的定制性，因此在老旧的手机下可以定制精简下linux系统，只安装核心程序，为跑后面的web服务腾出点系统资源。 1) 首先查看手机CPU属于什么架构，目前的主流手机基本都采用的是arm架构处理器，我一共有2台安卓手机，都是华为荣耀系列的，一个是3C移动版，另外一个是4C移动联通4G板，下面只针对荣耀4C如何安装linux系统做介绍： 网上查询了下荣耀4C是海思麒麟620处理器，属于armv7以上系列的，因此可以下载对应版本的linux版本。然后进入到archlinux arm官方网站查询armv7可以对应哪些安装系统。 这里我们选用ODROID-X这种参数对应的系统版本，那到哪儿下载怎么安装呢，接下来就是linux镜像制作了。 2) 经过这几天的网上搜索，发现sourceforge上有个开源的linux on android 项目，如下图所示：里面有各个版本的linux发行版，比如Ubuntu，Kali Linux以及Archlinux系统。这里我们选用Archlinux系统，将其镜像下载下来，同时把对应的安装脚本一并下载下来后进行安装。这里我最终没有选用该开源项目的版本主要原因是版本太老了，挂载在手机后用pacman -Syu升级的时候直接提示未知错误，无法升级到最新版本，而且安装某些软件后，对其他已有软件造成so冲突。这里下载下来的原因主要是挂载之后，我们看下有哪些系统目录及关键文件（比如内核文件有哪些，看下/boot目录就知道了里面就一个zImage文件），便于后面自己创建镜像的时候有个把握。 3) 制作Linux img镜像文件，这里我在台式电脑上创建一个img文件，大小为3.5G左右。这里主要考虑到我的荣耀手机内部存储空间还剩下3.7G左右大小，其中还需要200M左右的空间来安装超级终端和juiceSSH等安卓程序，其他剩余空间就全部用来挂载该镜像了。打开pc端的linux终端控制台，输入如下命令： dd if=/dev/zero of=archlinux.img bs=1M count=3500创建好之后，利用系统格式化命令来格式化该镜像文件(这里选用linux最新的ext4格式)： mkfs.ext4 archlinux.img都弄好之后，我们将该系统挂载到/mnt目录下，以备后面使用。mount -o rw,loop archlinux.img /mnt 4) 在网易镜像网站（http://mirrors.163.com）上下载最新的系统安装包文件，这里我们选择开头介绍的odroid-x系统包文件。下载下来之后解压缩，将对应的目录放入到之前挂载好的/mnt路径下。结合开源项目下的文件存放路径，我们将下载的所有文件目录拷贝到挂载的img镜像中去，然后再umount /mnt 一下。这样archlinux.img文件中已经有了我们最新下载的系统文件了。这里我们借用开源镜像的bootscript.sh脚本，里面有最为关键的一部分如下所示，我们需要根据手机实际情况进行修改： 12345678910111213141516171819 $bbox mount -t ext4 &#x2F;dev&#x2F;block&#x2F;loop255 $mnt if [ $? -ne 0 ];then error_exit &quot;Unable to mount the loop device!&quot;; fi ########################################### # Mount all required partitions # ########################################### $bbox mount -t devpts devpts $mnt&#x2F;dev&#x2F;pts; if [ $? -ne 0 ]; then $bbox mount -o bind &#x2F;dev $mnt&#x2F;dev; $bbox mount -t devpts devpts $mnt&#x2F;dev&#x2F;pts; fi if [ $? -ne 0 ]; then error_exit &quot;Unable to mount $mnt&#x2F;dev!&quot;; fi $bbox mount -t proc proc $mnt&#x2F;proc if [ $? -ne 0 ];then error_exit &quot;Unable to mount $mnt&#x2F;proc!&quot;; fi $bbox mount -o bind &#x2F;sys $mnt&#x2F;sysif [ $? -ne 0 ];then error_exit &quot;Unable to mount $mnt&#x2F;sys!&quot;; fi$bbox mount -o bind &#x2F;sdcard $mnt&#x2F;sdcardif [ $? -ne 0 ];then error_exit &quot;Unable to bind $mnt&#x2F;sdcard!&quot;; fiif [[ ! -d $mnt&#x2F;root&#x2F;cfg ]]; then mkdir $mnt&#x2F;root&#x2F;cfg; fi$bbox mount -o bind $(dirname $imgfile) $mnt&#x2F;root&#x2F;cfg 修改之后，将archlinux.img放入到手机内存卡上，然后手机开启超级终端后，进入到内部存储对应的目录下，直接输入sh bootscript.sh就可以挂载了。这里便于演示，我直接用adb shell进入手机中，挂载这一流程： 需要注意的是，如果之前已经挂载过了，再次挂载时，可能会有如下错误提示：unable to attach …此时，我们只需要reboot一下手机就可以了。 至此，安装上搭建linux系统已经完成，手机上运行archlinux系统跟PC上其实没啥区别，运行后需要修改源地址：在/etc/pacman.d/mirrorlist中将server地址修改为163的，这样速度会比原有的快很多。Server = http://mirrors.163.com/archlinuxarm/$arch/$repo 5) 部署手机web服务，看下内网能否连上web服务器，这里我们利用开源的facebooc来进行测试，首先git clone该项目，然后进入到src目录后修改main.c函数中的端口8080，将其修改为80，然后编译，运行(make run)。 打开chrome浏览器，输入手机IP地址，查看是否有Facebooc的首页： 6）借用花生壳，实现内网穿透，在外面也能访问手机上部署的网站。首先在花生壳官方网站https://www.oray.com/注册一个账户，可以免费得到一个壳域名，不过我这里用的是自己花钱买的顶级域名www.sunjunior.cn，注册之后，还需要开通内网穿透服务，我选择的是免费版的（开通费是6元），开通之后，每个月有1G流量，对于个人博客来说已经足够用了。这里由于是手机客户端，我们需要下载树莓派的版本客户端（CPU架构和手机一样的，所以可以使用）：下载之后，由于是deb包，需要解压之后得到data.tar文件包，然后再用tar xvf data.tar -C / 命令解压到文件系统中，后面的使用说明可以参考官网的链接http://service.oray.com/question/2680.html。这里演示下如何在手机和花生壳网站开启内网穿透服务（花生壳网站中设置端口映射，将手机所在本地IP地址设置为映射的目的地址，用自诊断测试下，如果能连接成功那说明配置成功）：这样，我们再次在chrome中输入www.sunjunior.cn的时候，就会转发到手机的web服务了，手机上也会收到web请求。这里需要注意的是，手机具有休眠功能，为了防止休眠，可以在手机设置免休眠功能，或者打开超级终端，设置开启唤醒锁和开启Wifi锁）。这样手机长时间开启就不会因为休眠关web服务了。总结：通过以上步骤，我们可以把一台闲置的手机搭建个人博客，或者建立低流量web网站。手机安装个screenfetch指令，可以将手机的信息列出来，当然也可以直接用 cat /proc/cpuinfo 和 cat /proc/meminfo查看手机信息，跟电脑上使用没啥两样。 ======下一步研究下安装手机启动时如何加载linux内核流程，如果能修改启动脚本，开启手机后直接进入archlinux就完美了，看看能不能实现吧！======**","categories":[],"tags":[]},{"title":"DUP函数的使用场景","slug":"DUP","date":"2017-08-31T23:45:51.000Z","updated":"2018-01-18T13:42:50.585Z","comments":true,"path":"2017/09/01/DUP/","link":"","permalink":"http://sunjunior.cn/2017/09/01/DUP/","excerpt":"","text":"dup函数是用来复制一个现有的文件描述符，UNIX-LIKE系统下提供了2个这样函数，原型如下(由unistd.h头文件提供)： int dup(int filedes); int dup2(int filedes, int filedes2); 根据APUE书中所讲，dup返回的新文件描述符是可用文件描述符中的最小数值，而dup2可用用filedes2参数指定新描述符的数值。如果filedes2已经打开，则将其关闭。这些函数返回的新文件描述符与被复制的filedes共享同一个文件表项，具体可以查看APUE文档说明。在实际应用项目中，主要是用于标准输出重定向。比如项目中有许多标准输出调试函数（默认启动一个进程时，操作系统默认分配了文件描述符0,1,2给该进程）。有时候需要将这些调试函数输出信息写入到文本文件中去，如何能一次复用现有调试函数而不是推倒重写，那最简单的就是将这些标准输出信息重定向到指定的文本文件中。那就需要用到这2个函数了。 需要注意的是，用这两个函数重定向标准输出时，一定是配合起来用的。由于dup2使用时会关闭filedes2，这里一般指的是标准输出（文件描述符为STDOUT_FILENO，值为1）。需要先用dup函数将其文件描述符保存起来，便于后面重新恢复打印到标准输出中来。另外还有一点就是，如果原有项目中用的是带I/O缓冲函数，即C语言标准库函数，如fprintf, fread,fwrite,printf等等，需要及时用fflush函数刷新到磁盘文件中去，不然很可能还会显示到标准输出中。实际项目中可以用2个函数封装好之后，注入到现有函数的最前面和结尾，一个函数用于将标准输出重定向到文件，另一个函数用于恢复标准输出。下面是演示代码： /* * ===================================================================================== * * Filename: dup.c * * Description: 复制一个文件描述符，用于标准输出重定向 * * Version: 1.0 * Created: 2017年08月30日 20时03分45秒 * Revision: none * Compiler: gcc * * Author: St.John * Organization: * * ===================================================================================== */ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;fcntl.h&gt; int main() { int newfd; int oldfd; oldfd = dup(STDOUT_FILENO); /* 把标准输出文件描述符先保存起来 */ if (oldfd &lt; 0) { perror(&quot;creat error&quot;); exit(0); } newfd = open(&quot;test.txt&quot;, O_RDWR | O_CREAT | O_TRUNC); if (newfd == -1) { perror(&quot;open failed&quot;); exit(0); } if (dup2(newfd, STDOUT_FILENO) &lt; 0) //这里文件描述符STDOUT_FILENO会关闭，所以先用dup保存起来，便于后面恢复标准输出 { perror(&quot;dup2 error&quot;); exit(0); } printf(&quot;TEXT I am going to sleep now\\n&quot;); fflush(stdout); //这里需要强制刷新IO缓存，否则可能还会显示到标准输出 if (dup2(oldfd, STDOUT_FILENO) &lt; 0) { perror(&quot;can not dup to stdout&quot;); exit(0); } printf(&quot;Now show on stdout\\n&quot;) ; //将标准输出重定向到txt文件中 return 0; } 另外还说明一点，复制一个描述符另一种方法就是使用fcntl函数，不过与dup系列函数不同的是，dup2函数是原子操作，而fcntl相当于先关闭文件，然后再复制文件描述符。","categories":[],"tags":[{"name":"APUE学习笔记","slug":"APUE学习笔记","permalink":"http://sunjunior.cn/tags/APUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"FSM有限状态机在工程中的运用","slug":"FSM","date":"2017-08-25T23:48:37.000Z","updated":"2018-01-18T13:43:14.065Z","comments":true,"path":"2017/08/26/FSM/","link":"","permalink":"http://sunjunior.cn/2017/08/26/FSM/","excerpt":"","text":"FSM有限状态机在工程项目中的运用============================================= 在Wikipedia解释中，有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型 。有限状态机描述了一个对象在其生命周期内所有可能的状态，以及对外界事件所做出的反应和动作。在简单的逻辑判断中，我们常用if—else条件判断来满足一定的流程。但是在状态复杂且状态之间的迁移也有多种情况下，用if—else判断会显着代码逻辑混乱无章可循。而有限状态机在处理复杂逻辑时，恰恰能简化逻辑关系，框架简单明了，可扩展性强。有限状态机应用场景挺广泛的，无论是实体对象还是抽象对象，只要满足有限状态机的几个条件，都可以用有限状态机实现。比如电商的购物流程，甚至连个人吃饭睡觉的描述过程都可以用状态机来实现。状态机一般处理内部状态比较复杂的场景有其独到的优点；另外一点状态机还可以实现正则匹配，比如匹配IP地址，匹配指定字符，数字等等。状态机实现主要包含四部分： 一个用来描述对象所有状态的集合，这里我们记作FSM_STATE； 一个用来描述外界事件通知的集合，这里我们记作FSM_EVENT； 一个用来描述对象对外界事件所做出动作的集合，这里我们记作FSM_ACTION； 一个用来表示从一个状态跃迁到另一状态的状态转移表，这里记作fsmTable 下面还是以STC89C52芯片上实现点灯为例，来说明这一实现流程。将二极管灯看做一个对象，其状态有2个，一个是灯亮，一个是灯灭。每一种状态对外界事件的相应是不同的，比如灯灭的时候，如果出现一个点亮灯的事件，那么灯状态变为灯亮；而如果出现一个熄灯事件，则什么事件也不操作，还是处于灯灭状态。下面是LED用FSM实现的完整代码： #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef unsigned int UINT32; typedef unsigned char UCHAR; typedef void VOID; //定义LED灯状态集合 typedef enum tagFSM_STATE { LED_POWER_OFF_STATE = 0, LED_POWER_ON_STATE, FSM_STATE_MAX } FSM_STATE_E; //定义LED灯的事件集合 typedef enum tagFSM_EVENT { LED_BUTTON_ON_EVENT = 0, LED_BUTTON_OFF_EVENT, FSM_EVENT_MAX, } FSM_EVENT_E; //定义LED动作函数表集合 typedef enum tagFSM_ACTION { LED_POWER_ACT_NONE, LED_POWER_OFF_ACTION, LED_POWER_ON_ACTION, FSM_ACTION_MAX, } FSM_ACTION_E; //定义状态转移数据结构 typedef struct tagFSM_Entry_S { UCHAR ucNextState; UCHAR ucAction; } FSM_Entry_S; FSM_Entry_S g_astFsmActions[FSM_EVENT_MAX][FSM_STATE_MAX] = { /* LED_BUTTON_ON_EVENT */ { {LED_POWER_ON_STATE, LED_POWER_ON_ACTION }, {LED_POWER_ON_STATE, LED_POWER_ACT_NONE } }, /* LED_BUTTON_OFF_EVENT */ { {LED_POWER_OFF_STATE, LED_POWER_ACT_NONE}, {LED_POWER_OFF_STATE, LED_POWER_OFF_ACTION} } }; typedef UINT32 (*FSM_ACTION_FUN)(UINT32 uiEventID, VOID *msg, VOID *pThis); UINT32 LedPowerOn(UINT32 uiEventID, VOID *msg, VOID *pThis) { printf(&quot;LedPowerOn uiEventID = %d, msg = %s\\n&quot;, uiEventID, (char*)msg); return 0; } UINT32 LedPowerOff(UINT32 uiEventID, VOID *msg, VOID *pThis) { printf(&quot;LedPowerOff uiEventID = %d, msg = %s\\n&quot;, uiEventID, (char*)msg); return 0; } UINT32 LedDumpAction(UINT32 uiEventID, VOID *msg, VOID *pThis) { printf(&quot;Nothing done uiEventID = %d, msg = %s\\n&quot;, uiEventID, (char*)msg); return 0; } FSM_ACTION_FUN g_astActFunction[FSM_ACTION_MAX] = { LedDumpAction, LedPowerOff, LedPowerOn, }; UINT32 g_uiFsmState = LED_POWER_OFF_STATE; #define FSM_GET_CUR_STATE(pThis) (g_uiFsmState) #define FSM_SET_CUR_STATE(value, pThis) (g_uiFsmState = (value)) typedef struct tagFSM_INPUT_S { UINT32 uiEventID; VOID *msg; VOID *pThis; } FSM_INPUT_S; UINT32 FSM_Execute_event(FSM_INPUT_S *pstInputInfo) { UINT32 uiState; UINT32 uiAction; UINT32 uiOldState; UINT32 uiRet = 0; if (pstInputInfo == NULL || pstInputInfo-&gt;uiEventID &gt;= FSM_EVENT_MAX) { return 0xffffffff; } uiState = FSM_GET_CUR_STATE(pThis); uiOldState = uiState; uiAction = g_astFsmActions[pstInputInfo-&gt;uiEventID][uiState].ucAction; //获取当前执行的动作 uiState = g_astFsmActions[pstInputInfo-&gt;uiEventID][uiState].ucNextState; //获取下一个状态 //状态变化了，记录一下日志 if (uiOldState != uiState) { printf(&quot;oldState = %u, newState = %u\\n&quot;, uiOldState, uiState); } FSM_SET_CUR_STATE(uiState, pThis); uiRet = g_astActFunction[uiAction](pstInputInfo-&gt;uiEventID, pstInputInfo-&gt;msg, pstInputInfo-&gt;pThis); return uiRet; } int main() { FSM_INPUT_S stInputInfo; stInputInfo.msg = malloc(128); memcpy(stInputInfo.msg, &quot;Hello, world\\n&quot;, sizeof(&quot;Hello, world\\n&quot;)); stInputInfo.uiEventID = LED_BUTTON_ON_EVENT; stInputInfo.pThis = NULL; FSM_Execute_event(&amp;stInputInfo); FSM_Execute_event(&amp;stInputInfo); FSM_Execute_event(&amp;stInputInfo); free(stInputInfo.msg); return 0; } 总结：通过对FSM整个原理的了解以及对FSM运用场景的掌握，后面如果出现业务场景比较复杂的情况下，可以优先考虑用有限状态机搭建业务逻辑框架，减少代码复杂度。","categories":[],"tags":[{"name":"编程实践","slug":"编程实践","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]},{"title":"51单片机串口模式下的编程实践","slug":"STC89C52","date":"2017-08-24T23:49:58.000Z","updated":"2020-05-04T00:45:08.001Z","comments":true,"path":"2017/08/25/STC89C52/","link":"","permalink":"http://sunjunior.cn/2017/08/25/STC89C52/","excerpt":"","text":"51单片机串口模式下的编程实践嵌入式领域工作5年，说实话，自己对嵌入式设备硬件还是在一知半解状态，工作中接触最多的就是硬件编程了，什么NIOS，FPGA，CPLD，I2C，SMI，EEPROM等专业词汇满天飞。而自己对这些元器件或者接口只知道大概作用，具体为什么有这种特性也不了解。好在我负责嵌入式软件层面的东西，对硬件东西不需要了解太深。最近在某宝上买了个51单片机，赠送了一大堆视频，主要讲解了一些器件的电气特性及工作原理，我不懂电路分析，也是懂非懂的，视频中讲解了如何点灯，如何数码管显示，如何获取温度，串口通讯等内容。 我自己也开始慢慢研究如何在设备上调试写代码，结合我5年代码的功力，觉得应该在串口模式下把这些功能集中在一个程序中。简单一点说就是，利用串口发送对应的指令与单片机通讯，单片机内部解析后做相应的动作。代码本身不太难，不过由于空ROM空间有限，如何在有限的空间上发挥设备的最大作用也是一个挑战点，需要对代码适当作优化。我们可以把常用的表驱动法，FSM有限状态机等编程模式带入到这个实验中去（这些奇技淫巧在项目代码中也最为常见）。下面是C代码实现（51单片机没有操作系统，直接对地址进行操作）： typedef unsigned int u16; //对数据类型进行声明定义 typedef unsigned char u8; /******************************************************************************* * 函数名 :UsartInit() * 函数功能 :设置串口 * 输入 : 无 * 输出 : 无 *******************************************************************************/ void UsartInit() { SCON = 0X50; //设置为工作方式1 TMOD = 0X20; //设置计数器工作方式2 PCON = 0X80; //波特率加倍 TH1 = 0XF3; //计数器初始值设置，注意波特率是4800的 TL1= 0XF3; ES = 1; //打开接收中断 EA = 1; //打开总中断 TR1 = 1; //打开计数器 } void Uart232SendByte(u8 data) { SBUF = data;//将接收到的数据放入到发送寄存器 while(!TI); //等待发送数据完成 TI = 0; //清除发送完成标志位 } void Uart232SendMsg(char *msg) { u8 length = strlen(msg); u8 index; if (length == 0) { return; } for (index = 0; index &lt; length; index++) { Uart232SendByte(msg[index]); } Uart232SendByte(&#39;\\n&#39;); } typedef void(*UART_FUNC)(char *para1, char *para2) __reentrant; typedef struct tagUart232FuncMap { const char *cmd; UART_FUNC func; } Uart232FuncMap; #define LED P2 //n数据进行左移s操作,数据位宽为t #define ROTATE_LEFT(n, s, t) ((n &lt;&lt; s) | (n &gt;&gt; (t - s))) #define ROTATE_RIGHT(n, s, t) ((n &gt;&gt; s) | (n &lt;&lt; (t - s))) __xdata u8 buffer[48] = {0}; void Uart232LedProc(char *para1, char *para2) __reentrant { //led点灯动作 __xdata static u8 ledValue = 0x1; LED = ledValue; LED = ROTATE_LEFT(LED, 1, 8); ledValue = LED; sprintf(buffer, &quot;led operation, para1 = %s, para2 = %s\\n&quot;, para1, para2); Uart232SendMsg(buffer); } #define DIGIT_MAXSIZE 8 void addProc(const char *para1, const char *para2) __reentrant { u8 a[DIGIT_MAXSIZE] = {0}; u8 b[DIGIT_MAXSIZE] = {0}; u8 length1 = strlen(para1); u8 length2 = strlen(para2); u8 index = 0; u8 carry = 0; u8 offset = 0; for (index = 0; index &lt; length1 &amp;&amp; index &lt; DIGIT_MAXSIZE; index++) { a[index] = para1[length1 - 1 - index] - &#39;0&#39;; } for (index = 0; index &lt; length2 &amp;&amp; index &lt; DIGIT_MAXSIZE; index++) { b[index] = para2[length2 - 1 - index] - &#39;0&#39;; } for (index = 0; index &lt; DIGIT_MAXSIZE; index++) { a[index] = a[index] + b[index] + carry; carry = a[index] / 10; a[index] %= 10; } offset += sprintf(buffer + offset, &quot;%s + %s = &quot;, para1, para2); //判断index不为负数 for (index = DIGIT_MAXSIZE - 1; (index &amp; 0x80) != 0x80 ; index--) { if(a[index]) //找到第一个最高位不为0，找不到时，index为-1 { break; } } if ((index &amp; 0x80) == 0x80) //index可能为负数,先排除掉 { offset += sprintf(buffer + offset, &quot;%c&quot;, &#39;0&#39;); } while ((index &amp; 0x80) != 0x80) { offset += sprintf(buffer + offset, &quot;%c&quot;, a[index] + &#39;0&#39;); index--; } Uart232SendMsg(buffer); } void Uart232AddProc(char *para1, char *para2) __reentrant { addProc(para1, para2); } #define LSA P2_2 #define LSB P2_3 #define LSC P2_4 #define NUM 8 __code u8 digitsMap[10] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f}; void DigDisplay() __reentrant { __xdata static u8 i = 0; i %= 8; P0 = 0; //先消失，后显示 switch(i % 8) //位选，选择点亮的数码管， { case(0): LSA=0; LSB=0; LSC=0; break;//显示第0位 case(1): LSA=1; LSB=0; LSC=0; break;//显示第1位 case(2): LSA=0; LSB=1; LSC=0; break;//显示第2位 case(3): LSA=1; LSB=1; LSC=0; break;//显示第3位 case(4): LSA=0; LSB=0; LSC=1; break;//显示第4位 case(5): LSA=1; LSB=0; LSC=1; break;//显示第5位 case(6): LSA=0; LSB=1; LSC=1; break;//显示第6位 case(7): LSA=1; LSB=1; LSC=1; break;//显示第7位 } P0=digitsMap[i];//发送段码 i++; } void Uart232DigitProc(char *para1, char *para2) __reentrant { sprintf(buffer, &quot;digit operation, para1 = %s, para2 = %s\\n&quot;, para1, para2); DigDisplay(); Uart232SendMsg(buffer); } void Uart232SetTimerProc(char *para1, char *para2) __reentrant { sprintf(buffer, &quot;timer operation, para1 = %s, para2 = %s\\n&quot;, para1, para2); Uart232SendMsg(buffer); } __code Uart232FuncMap g_usartFunMap[] = { {&quot;led&quot;, Uart232LedProc}, {&quot;add&quot;, Uart232AddProc}, {&quot;digit&quot;, Uart232DigitProc}, {&quot;timer&quot;, Uart232SetTimerProc}, }; void Uart232CmdProc(char *cmd, char *para1, char *para2) { u8 index; UART_FUNC cmdFun = NULL; for (index = 0; index &lt; sizeof(g_usartFunMap)/sizeof(g_usartFunMap[0]); index++) { if (strcmp(cmd, g_usartFunMap[index].cmd) == 0) //如果相同的话 { cmdFun = g_usartFunMap[index].func; break; } } if (index == sizeof(g_usartFunMap)/sizeof(g_usartFunMap[0])) //没有找到 { Uart232SendMsg(&quot;cmd not found\\n&quot;); return; } cmdFun(para1, para2); //调用函数 } #define BUFFER_MAXSIZE 16 u8 g_ucPos = 0; u8 g_ucValidFlag = 0; u8 receiveData[BUFFER_MAXSIZE] = {0}; //提取参数, 最多只支持2个参数 u8 Uart232ExtractParams(char *str, char *cmd, char *para1, char *para2) __critical { u8 index = 0; char *ptr = NULL; const char *delim = &quot; &quot;; char *para[3] = {cmd, para1, para2}; for(ptr = strtok(str, delim); ptr != NULL; ptr = strtok(NULL, delim)) { memcpy(para[index++], ptr, BUFFER_MAXSIZE); } if (index &gt; 3) { return 0xff; } return 0; } void Usart() __interrupt 4 { u8 temp; while (RI == 1) { RI = 0;//清除接收中断标志位 temp = SBUF;//接收到的数据 if (temp == &#39;\\r&#39; || temp == &#39;\\n&#39;) { g_ucValidFlag = 1; g_ucPos = 0; //清除位置 break; } receiveData[g_ucPos++] = temp; } if (g_ucPos &gt;= BUFFER_MAXSIZE) { g_ucPos = 0; //清除位置 } } /******************************************************************************* * 函 数 名 : main * 函数功能 : 主函数 * 输 入 : 无 * 输 出 : 无 *******************************************************************************/ void main() { u8 cmd[BUFFER_MAXSIZE]; u8 aPara1[BUFFER_MAXSIZE]; u8 aPara2[BUFFER_MAXSIZE]; UsartInit(); // 串口初始化 while(1) { if (g_ucValidFlag == 1) { //这里提取命令字和参数，然后调用函数 Uart232SendMsg(receiveData); if (0 == Uart232ExtractParams(receiveData, cmd, aPara1, aPara2)) { Uart232CmdProc(cmd, aPara1, aPara2); } memset(receiveData, 0x0, BUFFER_MAXSIZE); memset(cmd, 0x0, BUFFER_MAXSIZE); memset(aPara1, 0x0, BUFFER_MAXSIZE); memset(aPara2, 0x0, BUFFER_MAXSIZE); g_ucValidFlag = 0; //表示可以处理了 } } } 由于我本人主要在linux上编程学习，这里我选用的是SDCC编译器，语法上与keil有少许差异。用SDCC加上CodeBlocks集成开发环境简直是完美，Codeblocks IDE本身也是支持创建MCS8051工程的。唯一遗憾的是将程序烧录到开发板中目前没有太好的方法(我用的是STC89C52芯片)，这里我还是用另外一台windows电脑烧录的，用winscp工具将生成好的hex程序从linux拷贝到windows上进行烧录的。下面放几张图片：","categories":[],"tags":[{"name":"编程实践","slug":"编程实践","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]}],"categories":[],"tags":[{"name":"研发","slug":"研发","permalink":"http://sunjunior.cn/tags/%E7%A0%94%E5%8F%91/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://sunjunior.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"编程语言","slug":"编程语言","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"软件开发","slug":"软件开发","permalink":"http://sunjunior.cn/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"驾考经验","slug":"驾考经验","permalink":"http://sunjunior.cn/tags/%E9%A9%BE%E8%80%83%E7%BB%8F%E9%AA%8C/"},{"name":"VPN科学上网","slug":"VPN科学上网","permalink":"http://sunjunior.cn/tags/VPN%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Linux系统修复","slug":"Linux系统修复","permalink":"http://sunjunior.cn/tags/Linux%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8D/"},{"name":"编程实践","slug":"编程实践","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"},{"name":"编程人生","slug":"编程人生","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"},{"name":"编程思想","slug":"编程思想","permalink":"http://sunjunior.cn/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"APUE学习笔记","slug":"APUE学习笔记","permalink":"http://sunjunior.cn/tags/APUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}